"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[42101],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=o,h=c["".concat(l,".").concat(m)]||c[m]||p[m]||i;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},22804:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=n(87462),o=(n(67294),n(3905));const i={},r="Native Tokens and Foundries",s={unversionedId:"explanations/ledger/foundry",id:"explanations/ledger/foundry",title:"Native Tokens and Foundries",description:"Stardust introduces the concept of native tokens, or also called user-defined custom tokens. These tokens are minted",source:"@site/next/external/introduction-docs/docs/explanations/ledger/foundry.md",sourceDirName:"explanations/ledger",slug:"/explanations/ledger/foundry",permalink:"/next/introduction/explanations/ledger/foundry",draft:!1,editUrl:"https://github.com/iotaledger/chrysalis-docs/edit/develop/docs/next/external/introduction-docs/docs/explanations/ledger/foundry.md",tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Alias Transactions",permalink:"/next/introduction/explanations/ledger/alias"},next:{title:"Non-fungible Tokens",permalink:"/next/introduction/explanations/ledger/nft"}},l={},d=[{value:"Creating a Foundry",id:"creating-a-foundry",level:2},{value:"Minting tokens",id:"minting-tokens",level:2},{value:"Melting tokens",id:"melting-tokens",level:2},{value:"Burning tokens",id:"burning-tokens",level:2},{value:"Transferring native tokens with storage deposit",id:"transferring-native-tokens-with-storage-deposit",level:2},{value:"Conditional transfer of native tokens",id:"conditional-transfer-of-native-tokens",level:2}],u={toc:d};function p(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"native-tokens-and-foundries"},"Native Tokens and Foundries"),(0,o.kt)("p",null,"Stardust introduces the concept of native tokens, or also called user-defined custom tokens. These tokens are minted\ninto existence by token foundries, represented as ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#foundry-output"},(0,o.kt)("em",{parentName:"a"},"Foundry Outputs"))," on protocol level. The foundry defines the\nsupply control rules, that is, how many tokens can ever be created."),(0,o.kt)("p",null,"All outputs in the ledger support holding native tokens, therefore to transact with native tokens users don't need the\napproval of the foundry. Once native tokens are minted, they function as digital cash. The foundry acts as the central\nbank controlling supply via minting new tokens or buying back tokens from the market to be melted, hence decreasing the\navailable supply. Users have the ability to burn native tokens in their possession, which is equivalent to sending\nthe to-be burnt tokens to the zero address."),(0,o.kt)("p",null,"Foundries can only be created and controlled by alias accounts. Smart contract chains therefore can also act as token issuers\non L1 and leverage the framework for L2 asset wrapping and inter-L2-chain transfers."),(0,o.kt)("h2",{id:"creating-a-foundry"},"Creating a Foundry"),(0,o.kt)("p",null,"As mentioned above, only an alias can create new foundries, therefore the process starts with an existing ",(0,o.kt)("em",{parentName:"p"},"Alias Output"),".\nTo create a new foundry, simply state transition the alias and create a new ",(0,o.kt)("em",{parentName:"p"},"Foundry Output")," on the output side of the\ntransaction."),(0,o.kt)("p",null,"Transaction A shows an example transaction that creates a foundry:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The controlling alias is state transitioned, its ",(0,o.kt)("em",{parentName:"li"},"State Index")," and ",(0,o.kt)("em",{parentName:"li"},"Foundry Counter")," are incremented."),(0,o.kt)("li",{parentName:"ul"},"To cover for the storage deposit of the created ",(0,o.kt)("em",{parentName:"li"},"Foundry Output"),", the alias deposits 100i into the output."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("em",{parentName:"li"},"Serial Number")," of the foundry must correspond to the updated ",(0,o.kt)("em",{parentName:"li"},"Foundry Counter"),". Each foundry created by the alias\nis unique because of the unique ",(0,o.kt)("em",{parentName:"li"},"Serial Number"),"."),(0,o.kt)("li",{parentName:"ul"},"The foundry uses the ",(0,o.kt)("em",{parentName:"li"},"Simple Token Scheme")," as a supply control rule. It defines an upper cap (",(0,o.kt)("em",{parentName:"li"},"Maximum Supply"),") for\ntokens in circulation."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Minted Tokens")," defines how many tokens have been minted by the foundry. Since we don't immediately mint tokens in this\ntransaction, it is set to 0."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Melted Tokens")," defines how many tokens have been melted by the foundry. At creation there are no tokens to be melted,\ntherefore this must be 0."),(0,o.kt)("li",{parentName:"ul"},"Foundries support only one unlock condition, namely the ",(0,o.kt)("em",{parentName:"li"},"Immutable Alias Address Unlock Condition"),". It can never be changed\nduring the lifetime of the foundry, therefore the issuer role can only be transferred via the controlling alias."),(0,o.kt)("li",{parentName:"ul"},"Metadata about the token may be put in the ",(0,o.kt)("em",{parentName:"li"},"Immutable Metadata Feature")," of the foundry. For example, it may hold an\n",(0,o.kt)("a",{parentName:"li",href:"https://github.com/iotaledger/tips/blob/token-metadata-schema/tips/TIP-0030/tip-0030.md"},"IRC30")," compatible JSON file.\nBy hosting token metadata on-chain in a foundry output, we make the data available on all network nodes 24/7. There is\nno need for additional, off-chain metadata servers.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Transaction A - Creating a Foundry",src:n(54089).Z,width:"842",height:"1562"})),(0,o.kt)("h2",{id:"minting-tokens"},"Minting tokens"),(0,o.kt)("p",null,"Now that we have the foundry, it's time to mint native tokens. We simply need to transition the foundry in a transaction,\ndeclare that we mint tokens and place them in an output of our choice."),(0,o.kt)("p",null,"Tokens controlled by a foundry have a globally unique identifier, called ",(0,o.kt)("em",{parentName:"p"},"Token ID"),", that is derived from the properties\nof the foundry. To get the ",(0,o.kt)("em",{parentName:"p"},"Token ID"),", one has to concatenate:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the serialized ",(0,o.kt)("em",{parentName:"li"},"Alias Address")," that controls the foundry (33 bytes),"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("em",{parentName:"li"},"Serial Number")," of the foundry,"),(0,o.kt)("li",{parentName:"ul"},"and the ",(0,o.kt)("em",{parentName:"li"},"Token Scheme Type"),".")),(0,o.kt)("p",null,"By knowing the ",(0,o.kt)("em",{parentName:"p"},"Token ID"),", one can fetch current unspent foundry output from the Indexer API defined in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/tips/blob/indexer-api/tips/TIP-0026/tip-0026.md"},"TIP-26"),"."),(0,o.kt)("p",null,"Transaction B mints all available tokens in the foundry."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Minted Tokens")," in ",(0,o.kt)("em",{parentName:"li"},"Foundry Output #2")," is increased by the number of minted tokens, namely 1000."),(0,o.kt)("li",{parentName:"ul"},"500 tokens are minted into ",(0,o.kt)("em",{parentName:"li"},"Basic Output #1")," and locked to ",(0,o.kt)("em",{parentName:"li"},"mintAddress"),"."),(0,o.kt)("li",{parentName:"ul"},"500 tokens are minted into ",(0,o.kt)("em",{parentName:"li"},"Basic Output #2")," and locked to ",(0,o.kt)("em",{parentName:"li"},"vestAddress"),". Additionally, a timelock is specified on\nthe output so that these token can only be unlocked after May 24 2023 18:00:00.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Transaction B - Minting tokens",src:n(84027).Z,width:"842",height:"2432"})),(0,o.kt)("h2",{id:"melting-tokens"},"Melting tokens"),(0,o.kt)("p",null,"Melting tokens removes them from the circulating supply. Melting can only be carried out if the foundry is included in\nthe transaction."),(0,o.kt)("p",null,"Transaction C assumes that the token issuer is in control of ",(0,o.kt)("em",{parentName:"p"},"mintAddress")," where the to-be melted tokens are locked.\n250 tokens are being melted in foundry."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Melted Tokens")," of ",(0,o.kt)("em",{parentName:"li"},"Foundry Output #3")," is increased by the amount of melted tokens, 250."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Basic Output #3")," has only 250 tokens remaining. The input side of the transaction contains 500 tokens, but the output\nside only 250. By increasing ",(0,o.kt)("em",{parentName:"li"},"Melted Tokens")," on ",(0,o.kt)("em",{parentName:"li"},"Foundry Output #3")," the transaction becomes balanced."),(0,o.kt)("li",{parentName:"ul"},"Looking at ",(0,o.kt)("em",{parentName:"li"},"Foundry Output #3")," we can determine that the circulating supply of the token is ",(0,o.kt)("em",{parentName:"li"},"Minted Tokens")," - ",(0,o.kt)("em",{parentName:"li"},"Melted Tokens")," = 750."),(0,o.kt)("li",{parentName:"ul"},"In a subsequent transaction we could mint 250 tokens to reach ",(0,o.kt)("em",{parentName:"li"},"Maximum Supply")," again.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Transaction C - Melting tokens",src:n(85673).Z,width:"842",height:"2242"})),(0,o.kt)("h2",{id:"burning-tokens"},"Burning tokens"),(0,o.kt)("p",null,"Burning tokens by token holders without the involvement of the foundry is possible to prevent losing access to the\nstorage deposit of the underlying tokens. What would happen if ",(0,o.kt)("em",{parentName:"p"},"mintAddress")," in ",(0,o.kt)("em",{parentName:"p"},"Basic Output #3")," is not controlled by the\nissuer, but some other entity?"),(0,o.kt)("p",null,"They obviously can't melt the tokens without controlling the foundry, therefore they can't free up the base tokens (IOTA/SMR)\nin ",(0,o.kt)("em",{parentName:"p"},"Basic Output #3"),'. Unless the issuer buys back the tokens or someone else relieves the user by taking the tokens and\nrefunding the storage deposit, it is locked forever. Burning makes it possible to "forget" about these tokens and free\nup the storage deposit.'),(0,o.kt)("p",null,"Burnt tokens are no longer tracked in the ledger, therefore burning is conceptually equivalent to sending to the zero address\nwithout a storage deposit."),(0,o.kt)("p",null,"Transaction D burns all tokens in ",(0,o.kt)("em",{parentName:"p"},"Basic Output #3"),". Notice that ",(0,o.kt)("em",{parentName:"p"},"mintAddress")," doesn't have to have the approval of the\nfoundry and the controlling alias account."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Transaction D - Burning tokens",src:n(12907).Z,width:"842",height:"742"})),(0,o.kt)("h2",{id:"transferring-native-tokens-with-storage-deposit"},"Transferring native tokens with storage deposit"),(0,o.kt)("p",null,"Transferring native tokens is similar to transferring base tokens. The output that you create on the receiver's address\nhowever needs to have base tokens to cover for the storage deposit. Therefore, there are two ways to transfer native tokens:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Sending native tokens together with the required storage deposit. The sender loses access to the storage deposit."),(0,o.kt)("li",{parentName:"ul"},"Sending native tokens with ",(0,o.kt)("em",{parentName:"li"},"Storage Deposit Return Unlock Condition"),". The receiver has to claim the transfer by refunding\nthe storage deposit of the sender. The sender doesn't lose the storage deposit.")),(0,o.kt)("p",null,"The former method is depicted in Transaction E. Due to claiming in the latter method, it is called a conditional transfer, depicted in Transaction F.\n",(0,o.kt)("img",{alt:"Transaction E - Transferring native tokens with storage deposit",src:n(81417).Z,width:"842",height:"742"})),(0,o.kt)("h2",{id:"conditional-transfer-of-native-tokens"},"Conditional transfer of native tokens"),(0,o.kt)("p",null,"In order not to lose access to the storage deposit, two additional unlock conditions are defined on\n",(0,o.kt)("em",{parentName:"p"},"Basic Output #7")," in Transaction F:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A ",(0,o.kt)("em",{parentName:"li"},"Storage Deposit Return Unlock Condition")," that forces the consumer of the output to refund ",(0,o.kt)("em",{parentName:"li"},"Return Amount")," of base tokens to ",(0,o.kt)("em",{parentName:"li"},"Return Address"),","),(0,o.kt)("li",{parentName:"ul"},"and an ",(0,o.kt)("em",{parentName:"li"},"Expiration Unlock Condition")," that defines a time window until the recipient has to claim the transfer. If they don't do so,\nownership of ",(0,o.kt)("em",{parentName:"li"},"Basic Output #7")," bounces back to the sender and the ",(0,o.kt)("em",{parentName:"li"},"Storage Deposit Return Unlock Condition")," is ignored."),(0,o.kt)("li",{parentName:"ul"},"The expiration time is compared to the timestamp of the confirming milestone to decide whether the unlock is valid or not.")),(0,o.kt)("p",null,"Transaction F shows the creation of a conditional transfer:\n",(0,o.kt)("img",{alt:"Transaction F - Conditional transfer of native tokens",src:n(85244).Z,width:"842",height:"852"})),(0,o.kt)("p",null,'Once the "offer" is created, the recipient can claim the transfer until the expiration deadline. Transaction G shows\na successful claiming.'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Note that the recipient needs to sweep the native tokens into an output they already own to cover for the storage deposit, hence ",(0,o.kt)("em",{parentName:"li"},"Basic Output #8")," is unlocked in the transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"Basic Output #9")," refunds the sender with the storage deposit used to create ",(0,o.kt)("em",{parentName:"li"},"Basic Output #7"),".")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Transaction G - Claiming conditional transfer",src:n(68852).Z,width:"842",height:"1272"})))}p.isMDXComponent=!0},54089:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_A-72ec373721eb2711d5ac70ffea86ad02.svg"},84027:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_B-c55ab4ba3a2d7530363921a8d4ae6ead.svg"},85673:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_C-5b76e7d7845f66830b2165334e6f0965.svg"},12907:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_D-c8b6f3597f5fb39c61b2484a3d7c026b.svg"},81417:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_E-2126b1bcd8a65f079e9a93568e5d82c7.svg"},85244:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_F-9d025826f260c065c254e911f72dda2c.svg"},68852:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_G-aa922b0220b28b12db11eb946d46ffe2.svg"}}]);