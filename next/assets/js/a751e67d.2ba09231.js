"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[23752],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),i=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):c(c({},t),e)),a},u=function(e){var t=i(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=i(a),p=r,h=d["".concat(l,".").concat(p)]||d[p]||m[p]||o;return a?n.createElement(h,c(c({ref:t},u),{},{components:a})):n.createElement(h,c({ref:t},u))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,c=new Array(o);c[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,c[1]=s;for(var i=2;i<o;i++)c[i]=a[i];return n.createElement.apply(null,c)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},83349:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>m});var n=a(87462),r=(a(67294),a(3905)),o=a(34259),c=a(18679);const s={keywords:["value","Synchronous functions","function descriptor","smart contract chain","views","funcs"],description:"Synchronous calls can only be made between contracts that are running on the same contract chain. When calling a smart contract function you can only access the memory assigned to that specific smart contract, the only way to share data between smart contracts that call each other is through function parameters and return values.",image:"/img/logo/WASP_logo_dark.png"},l="Calling Functions",i={unversionedId:"guide/wasm_vm/call",id:"guide/wasm_vm/call",title:"Calling Functions",description:"Synchronous calls can only be made between contracts that are running on the same contract chain. When calling a smart contract function you can only access the memory assigned to that specific smart contract, the only way to share data between smart contracts that call each other is through function parameters and return values.",source:"@site/next/external/wasp/documentation/docs/guide/wasm_vm/call.mdx",sourceDirName:"guide/wasm_vm",slug:"/guide/wasm_vm/call",permalink:"/next/smart-contracts/guide/wasm_vm/call",draft:!1,editUrl:"https://github.com/iotaledger/wasp/edit/develop/documentation/next/external/wasp/documentation/docs/guide/wasm_vm/call.mdx",tags:[],version:"current",frontMatter:{keywords:["value","Synchronous functions","function descriptor","smart contract chain","views","funcs"],description:"Synchronous calls can only be made between contracts that are running on the same contract chain. When calling a smart contract function you can only access the memory assigned to that specific smart contract, the only way to share data between smart contracts that call each other is through function parameters and return values.",image:"/img/logo/WASP_logo_dark.png"},sidebar:"tutorialSidebar",previous:{title:"Function Descriptors",permalink:"/next/smart-contracts/guide/wasm_vm/funcdesc"},next:{title:"Posting Asynchronous Requests",permalink:"/next/smart-contracts/guide/wasm_vm/post"}},u={},m=[],d={toc:m};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"calling-functions"},"Calling Functions"),(0,r.kt)("p",null,"Synchronous function calls between smart contracts act very similar to how normal function\ncalls work in any programming language, but with a slight twist. With normal function\ncalls you share all the global memory that you can access with every function that you\ncall. However, when calling a smart contract function you can only access the memory\nassigned to that specific smart contract. Remember, each smart contract runs in its own\nsandbox environment. Therefore, the only way to share data between smart contracts that\ncall each other is through function parameters and return values."),(0,r.kt)("p",null,"Synchronous calls can only be made between contracts that are running on the same contract\nchain. The ISC host knows about all the contracts it is running on a chain, and therefore\nis able to dispatch the call to the correct contract function. The function descriptor is\nused to specify the call parameters (if any) through its ",(0,r.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/params"},"Params")," proxy, and\nto invoke the function through its ",(0,r.kt)("inlineCode",{parentName:"p"},"func")," interface."),(0,r.kt)("p",null,"In addition, when the function that is called is not a ",(0,r.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/views"},"View"),", it is possible\nto pass tokens to the function call through this interface. Note that the only way to call\na function and properly pass tokens to it ",(0,r.kt)("em",{parentName:"p"},"within the same chain")," is through the function\ndescriptor. Otherwise, the ",(0,r.kt)("inlineCode",{parentName:"p"},"allowance()")," function will not register any incoming tokens."),(0,r.kt)("p",null,"When the call is made, the calling function will be paused and wait for the called\nfunction to complete. After completion, it may access the returned values (if any) through\nthe ",(0,r.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/results"},"Results")," proxy of the function descriptor."),(0,r.kt)("p",null,"When calling a function from a View function, it is only possible to call other View\nfunctions. The ScFuncs interface enforces this at compile-time because it expects an\n",(0,r.kt)("inlineCode",{parentName:"p"},"ScViewContext")," to be passed to the constructor that creates the function descriptor."),(0,r.kt)("p",null,"Here's how a smart contract would tell a ",(0,r.kt)("inlineCode",{parentName:"p"},"dividend")," contract on the same chain to divide\nthe 1000 tokens it passes to the function:"),(0,r.kt)(o.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,r.kt)(c.Z,{value:"go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"f := dividend.ScFuncs.Divide(ctx)\nf.Func.TransferBaseTokens(1000).Call()\n"))),(0,r.kt)(c.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let f = dividend::ScFuncs::divide(ctx);\nf.func.transfer_base_tokens(1000).call();\n"))),(0,r.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let f = dividend.ScFuncs.divide(ctx);\nf.func.transferBaseTokens(1000).call();\n")))),(0,r.kt)("p",null,"And here is how a smart contract would ask a ",(0,r.kt)("inlineCode",{parentName:"p"},"dividend")," contract on the same chain to\nreturn the dispersion factor for a specific address:"),(0,r.kt)(o.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,r.kt)(c.Z,{value:"go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"f := dividend.ScFuncs.GetFactor(ctx)\nf.Params.Address().SetValue(address)\nf.Func.Call()\nfactor := f.Results.Factor().Value()\n"))),(0,r.kt)(c.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let f = dividend::ScFuncs::get_factor(ctx);\nf.params.address().set_value(&address);\nf.func.call();\nlet factor = f.results.factor().value();\n"))),(0,r.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let f = dividend.ScFuncs.getFactor(ctx);\nf.params.address().setValue(address);\nf.func.call();\nlet factor = f.results.factor().value();\n")))),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Create a function descriptor for the desired function."),(0,r.kt)("li",{parentName:"ol"},"Use the ",(0,r.kt)("a",{parentName:"li",href:"/next/smart-contracts/guide/wasm_vm/params"},"Params")," proxy in the descriptor to set its parameters."),(0,r.kt)("li",{parentName:"ol"},"Direct the ",(0,r.kt)("inlineCode",{parentName:"li"},"func")," member of the descriptor to call the associated function"),(0,r.kt)("li",{parentName:"ol"},"Use the ",(0,r.kt)("a",{parentName:"li",href:"/next/smart-contracts/guide/wasm_vm/results"},"Results")," proxy in the descriptor to retrieve its results.")),(0,r.kt)("p",null,'The function descriptors assume that the function to be called is associated with the\ndefault Hname of the contract, in this case ScHname::new("dividend"). If you deployed the\ncontract that contains the function you want to call under a different name, then you\nwould have to provide its associated Hname to the ',(0,r.kt)("inlineCode",{parentName:"p"},"func")," member through the of_contract()\nmember function like this:"),(0,r.kt)(o.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,r.kt)(c.Z,{value:"go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'altContract := NewScHname("alternateName")\nf := dividend.ScFuncs.Divide(ctx)\nf.Func.OfContract(altContract).TransferBaseTokens(1000).Call()\n'))),(0,r.kt)(c.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let alt_contract = ScHname::new("alternateName");\nlet f = dividend::ScFuncs::divide(ctx);\nf.func.of_contract(alt_contract).transfer_base_tokens(1000).call();\n'))),(0,r.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'let altContract = ScHname.fromString("alternateName");\nlet f = dividend.ScFuncs.divide(ctx);\nf.func.ofContract(altContract).transferBaseTokens(1000).call();\n')))),(0,r.kt)("p",null,"In the next section we will look at how to use function descriptors to\n",(0,r.kt)("a",{parentName:"p",href:"/next/smart-contracts/guide/wasm_vm/post"},"asynchronously call")," smart contract functions on any chain."))}p.isMDXComponent=!0},18679:(e,t,a)=>{a.d(t,{Z:()=>c});var n=a(67294),r=a(86010);const o="tabItem_Ymn6";function c(e){let{children:t,hidden:a,className:c}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,c),hidden:a},t)}},34259:(e,t,a)=>{a.d(t,{Z:()=>p});var n=a(87462),r=a(67294),o=a(86010),c=a(51048),s=a(33609),l=a(1943),i=a(72957);const u="tabList__CuJ",m="tabItem_LNqP";function d(e){var t;const{lazy:a,block:c,defaultValue:d,values:p,groupId:h,className:f}=e,g=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),v=p??g.map((e=>{let{props:{value:t,label:a,attributes:n}}=e;return{value:t,label:a,attributes:n}})),y=(0,s.l)(v,((e,t)=>e.value===t.value));if(y.length>0)throw new Error(`Docusaurus error: Duplicate values "${y.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const b=null===d?d:d??(null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)??g[0].props.value;if(null!==b&&!v.some((e=>e.value===b)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${b}" but none of its children has the corresponding value. Available values are: ${v.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:w}=(0,l.U)(),[x,T]=(0,r.useState)(b),N=[],{blockElementScrollPositionUntilNextRender:S}=(0,i.o5)();if(null!=h){const e=k[h];null!=e&&e!==x&&v.some((t=>t.value===e))&&T(e)}const _=e=>{const t=e.currentTarget,a=N.indexOf(t),n=v[a].value;n!==x&&(S(t),T(n),null!=h&&w(h,String(n)))},C=e=>{var t;let a=null;switch(e.key){case"ArrowRight":{const t=N.indexOf(e.currentTarget)+1;a=N[t]??N[0];break}case"ArrowLeft":{const t=N.indexOf(e.currentTarget)-1;a=N[t]??N[N.length-1];break}}null==(t=a)||t.focus()};return r.createElement("div",{className:(0,o.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":c},f)},v.map((e=>{let{value:t,label:a,attributes:c}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:x===t?0:-1,"aria-selected":x===t,key:t,ref:e=>N.push(e),onKeyDown:C,onFocus:_,onClick:_},c,{className:(0,o.Z)("tabs__item",m,null==c?void 0:c.className,{"tabs__item--active":x===t})}),a??t)}))),a?(0,r.cloneElement)(g.filter((e=>e.props.value===x))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==x})))))}function p(e){const t=(0,c.Z)();return r.createElement(d,(0,n.Z)({key:String(t)},e))}}}]);