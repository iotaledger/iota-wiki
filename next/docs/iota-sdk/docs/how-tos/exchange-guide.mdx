---
description: Easily integrate with your exchange, custody solution, or product using the IOTA SDK.
sidebar_label: Integrate IOTA SDK With Your Exchange
keywords:
  - integrate
  - exchange
  - account model
  - addresses
  - IOTA SDK
  - setup
  - NodeJS
  - explanation
---

import WarningUnlockConditions from '../_admonitions/_warning-unlock-conditions.md';

# Stardust Exchange Integration Guide

:::note

You can easily integrate the IOTA SDK in your exchange, custody solution, or product.

:::

:::warning

The stardust update allows for complex tokenization schemes that can lead to monetary losses if used incorrectly.
Transaction outputs may have multiple unlocking conditions which may require returning some or all of the amount, which could expire if not claimed in time, or which may not be unlockable for a very long time. You can lose money if you do not check the unlock conditions before accepting a deposit!

:::

## Integration Guide

This guide explains how to integrate the IOTA SDK in your exchange.

Features of the IOTA SDK:

- Secure seed management.
- Account management with multiple accounts and multiple addresses.
- Confirmation monitoring.
- Deposit address monitoring.
- Backup and restore functionality.

### How Does it Work?

The IOTA SDK is a stateful package with a standardized interface for developers to build applications involving value transactions. It offers abstractions to handle payments and can optionally interact with [Stronghold](https://wiki.iota.org/stronghold.rs/getting_started) for seed handling, seed storage, and state backup.

:::note

If you are not familiar with the IOTA SDK, you can find more information in the [documentation](../welcome.md).

:::

You can use the following examples as a guide to implementing _the multi-account approach_ using the `NodeJs` bindings:

1. [Set up the the IOTA SDK](#1-set-up-the-iota-sdk).
2. [Create an account for each user](#2-create-an-account-for-each-user).
3. [Generate a user address to deposit funds](#3-generate-a-user-address-to-deposit-funds).
4. [Check the user balance](#4-check-the-account-balance).
5. [Listen to events](#5-listen-to-events).
6. [Enable withdrawals](#6-enable-withdrawals).

:::note

If you are looking for other languages, please read the [IOTA SDK overview](../welcome/#your-application-in-the-iota-network).

:::

Since all IOTA SDK bindings are based on core principles provided by the IOTA SDK, the outlined approach is very similar regardless of the programming language you choose.

### 1. Set Up the IOTA SDK

First, you should install the components that are needed to use the IOTA SDK and the binding of your choice; it may vary a bit from language to language. In the case of the [NodeJs binding](../getting-started/nodejs.mdx), it is straightforward since it is distributed via the `npm` package manager.

You can read more about [backup and security in this guide](https://wiki.iota.org/shimmer/introduction/how_tos/backup_security).

```bash
npm install @iota/sdk dotenv
```

#### 1 Generate a mnemonic

```js reference
https://github.com/iotaledger/iota-sdk/tree/develop/bindings/nodejs/examples/exchange/0-generate-mnemonic.ts
```

You can then create a `.env` by running the following command:

```bash
touch .env
```

You can now add your `SH_PASSWORD` and `MNEMONIC` to the `.env` file.

```bash
SH_PASSWORD="here is your super secure password"
MNEMONIC="here is your super secure 24 word mnemonic, it's only needed here the first time"
```

After you have updated the `.env` file, you can initialize the `Wallet` instance with a secret manager([`Stronghold`](https://wiki.iota.org/stronghold.rs/welcome) by default) and client options.

:::note

Manage your password with the utmost care.

:::

By default, the Stronghold file will be called `wallet.stronghold`. It will store the seed (derived from the mnemonic) that serves as a cryptographic key from which all accounts and related addresses are generated.

One of the key principles behind the `stronghold` is that no one can get a seed out of it, so you should also back up your 24-word mnemonic in a secure place because there is no way to recover it from the `.stronghold` file. You deal with accounts using the `Wallet` instance exclusively, where all complexities are hidden under the hood and are dealt with securely.

:::note

Keep the `stronghold` password and the `stronghold` database on separate devices. See the [backup and security guide](https://wiki.iota.org/introduction/how_tos/backup_security/) for more information.

:::

#### 2 Create an Account for Each User

You can import the IOTA SDK and create a wallet using the following example:

```js reference
https://github.com/iotaledger/iota-sdk/tree/develop/bindings/nodejs/examples/exchange/1-create-account.ts
```

The `Alias` must be unique and can be whatever fits your use case. The `Alias` is typically used to identify an account later on. Each account is also represented by an `index` which is incremented by one every time a new account is created. You can refer to any account via its `index`, or `alias`.

You get an instance of any created account using `Wallet.getAccount(accountId|alias)` or get all accounts with `Wallet.getAccounts()`.

Common methods of `account` instance include:

- `account.addresses()` - returns list of addresses related to the account.
- `account.generateAddresses()` - generate a new address for the address index incremented by 1.
- `account.balance()` - returns the balance for the given account.
- `account.sync()` - sync the account information with the tangle.

### 3. Generate a User Address to Deposit Funds

The `wallet` module of the IOTA SDK is a stateful library. This means it caches all relevant information in storage to provide performance benefits while dealing with, potentially, many accounts and addresses.

```js reference
https://github.com/iotaledger/iota-sdk/tree/develop/bindings/nodejs/examples/exchange/2-generate-address.ts
```

Every account can have multiple addresses. Addresses are represented by an `index` which is incremented by one every time a new address is created. You can access the addresses using the `account.address()` method:

```javascript
const addresses = account.addresses();

console.log('Need a refill? Send it to this address:', addresses[0]);
```

You can use the [Faucet](https://faucet.testnet.shimmer.network/) to add test tokens and test your account.

There are two types of addresses, `internal` and `public` (external). This approach is known as a _BIP32 Hierarchical Deterministic wallet (HD Wallet)_.

- Each set of addresses is independent of each other and has an independent `index` id.
- Addresses that are created by `account.generateAddresses()` are indicated as `internal=false` (public).
- Internal addresses (`internal=true`) are called `change` addresses and are used to send the excess funds to them.

### 4. Check the Account Balance

<WarningUnlockConditions />

You can get the available account balance across all addresses of the given account using the following example:

```js reference
https://github.com/iotaledger/iota-sdk/tree/develop/bindings/nodejs/examples/exchange/3-check-balance.ts
```

### 5. Listen to Events

<WarningUnlockConditions />

The IOTA SDK supports several events for listening. A provided callback is triggered as soon as an event occurs (which usually happens during syncing).

You can use the following example to listen to new output events:

```js reference
https://github.com/iotaledger/iota-sdk/tree/develop/bindings/nodejs/examples/exchange/4-listen-events.ts
```

**Example output:**

```js
NewOutput: {
  output: {
    outputId: '0x2df0120a5e0ff2b941ec72dff3464a5b2c3ad8a0c96fe4c87243e4425b9a3fe30000',
    metadata: [Object],
    output: [Object],
    isSpent: false,
    address: [Object],
    networkId: '1862946857608115868',
    remainder: false,
    chain: [Array]
  },
  transaction: null,
  transactionInputs: null
}
```

Alternatively you can use `account.outputs()` to get all outputs that are stored in the account, or `account.unspentOutputs()`, to get only unspent outputs.

### 6. Enable Withdrawals

You can use the following example to send tokens to an address.

```js reference
https://github.com/iotaledger/iota-sdk/tree/develop/bindings/nodejs/examples/exchange/5-send-amount.ts
```

The full function signature is `account.send(outputs[, options])`.

Default options are fine and successful; however, you can provide additional options, such as `remainderValueStrategy`, which can have the following values:

- `changeAddress`: Send the remainder value to an internal address.
- `reuseAddress`: Send the remainder value back to its original address.
- `customAddress`: Send the remainder value back to a provided account address.

```js
TransactionOptions {
    remainderValueStrategy?: RemainderValueStrategy;
    taggedDataPayload?: ITaggedDataPayload;
    customInputs?: string[];
}
```

The `account.send()` function returns a `transaction` with it's id. The `blockId` can be used later for checking a confirmation status. You can obtain individual transactions related to the given account using the `account.transactions()` function.

:::note Dust Protection

When sending tokens, you should consider a [dust protection](https://wiki.iota.org/shimmer/tips/tips/TIP-0019) mechanism.

:::
