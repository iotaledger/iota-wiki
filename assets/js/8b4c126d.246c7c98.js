"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[94456],{36054:function(e){e.exports=JSON.parse('{"pluginId":"smart-contracts","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Overview","href":"/smart-contracts/overview","docId":"overview"},{"type":"category","label":"Core Concepts","items":[{"type":"link","label":"Smart Contracts","href":"/smart-contracts/guide/core_concepts/smart-contracts","docId":"guide/core_concepts/smart-contracts"},{"type":"link","label":"ISCP Architecture","href":"/smart-contracts/guide/core_concepts/iscp-architecture","docId":"guide/core_concepts/iscp-architecture"},{"type":"link","label":"Committees and Validators","href":"/smart-contracts/guide/core_concepts/validators","docId":"guide/core_concepts/validators"},{"type":"link","label":"Consensus","href":"/smart-contracts/guide/core_concepts/consensus","docId":"guide/core_concepts/consensus"},{"type":"link","label":"State, Transitions and State Anchoring","href":"/smart-contracts/guide/core_concepts/states","docId":"guide/core_concepts/states"},{"type":"link","label":"Anatomy of a Smart Contract","href":"/smart-contracts/guide/core_concepts/smart-contract-anatomy","docId":"guide/core_concepts/smart-contract-anatomy"},{"type":"link","label":"Sandbox Interface","href":"/smart-contracts/guide/core_concepts/sandbox","docId":"guide/core_concepts/sandbox"},{"type":"category","label":"Core Contracts","items":[{"type":"link","label":"Overview","href":"/smart-contracts/guide/core_concepts/core_contracts/overview","docId":"guide/core_concepts/core_contracts/overview"},{"type":"link","label":"Root","href":"/smart-contracts/guide/core_concepts/core_contracts/root","docId":"guide/core_concepts/core_contracts/root"},{"type":"link","label":"Default","href":"/smart-contracts/guide/core_concepts/core_contracts/default","docId":"guide/core_concepts/core_contracts/default"},{"type":"link","label":"Accounts","href":"/smart-contracts/guide/core_concepts/core_contracts/accounts","docId":"guide/core_concepts/core_contracts/accounts"},{"type":"link","label":"Blob","href":"/smart-contracts/guide/core_concepts/core_contracts/blob","docId":"guide/core_concepts/core_contracts/blob"},{"type":"link","label":"Blocklog","href":"/smart-contracts/guide/core_concepts/core_contracts/blocklog","docId":"guide/core_concepts/core_contracts/blocklog"},{"type":"link","label":"Governance","href":"/smart-contracts/guide/core_concepts/core_contracts/governance","docId":"guide/core_concepts/core_contracts/governance"}],"collapsible":true,"collapsed":true},{"type":"category","label":"Accounts","items":[{"type":"link","label":"How Accounts Work","href":"/smart-contracts/guide/core_concepts/accounts/how-accounts-work","docId":"guide/core_concepts/accounts/how-accounts-work"},{"type":"link","label":"How To Deposit To a Chain","href":"/smart-contracts/guide/core_concepts/accounts/how-to-deposit-to-a-chain","docId":"guide/core_concepts/accounts/how-to-deposit-to-a-chain"},{"type":"link","label":"How To Withdraw From a Chain","href":"/smart-contracts/guide/core_concepts/accounts/how-to-withdraw-from-a-chain","docId":"guide/core_concepts/accounts/how-to-withdraw-from-a-chain"},{"type":"link","label":"View Account Balances","href":"/smart-contracts/guide/core_concepts/accounts/view-account-balances","docId":"guide/core_concepts/accounts/view-account-balances"},{"type":"link","label":"The Common Account","href":"/smart-contracts/guide/core_concepts/accounts/the-common-account","docId":"guide/core_concepts/accounts/the-common-account"}],"collapsible":true,"collapsed":true},{"type":"category","label":"Interacting With Smart Contracts","items":[{"type":"link","label":"On-ledger Requests","href":"/smart-contracts/guide/core_concepts/smartcontract-interaction/on-ledger-requests","docId":"guide/core_concepts/smartcontract-interaction/on-ledger-requests"},{"type":"link","label":"Off-ledger Requests","href":"/smart-contracts/guide/core_concepts/smartcontract-interaction/off-ledger-requests","docId":"guide/core_concepts/smartcontract-interaction/off-ledger-requests"}],"collapsible":true,"collapsed":true},{"type":"category","label":"Solo","items":[{"type":"link","label":"Solo","href":"/smart-contracts/guide/solo/what-is-solo","docId":"guide/solo/what-is-solo"},{"type":"link","label":"First Example","href":"/smart-contracts/guide/solo/first-example","docId":"guide/solo/first-example"},{"type":"link","label":"Tokens and the UTXO Ledger","href":"/smart-contracts/guide/solo/tokens-and-utxos","docId":"guide/solo/tokens-and-utxos"},{"type":"link","label":"Invoking a Smart Contract","href":"/smart-contracts/guide/solo/invoking-sc","docId":"guide/solo/invoking-sc"},{"type":"link","label":"Calling a View","href":"/smart-contracts/guide/solo/view-sc","docId":"guide/solo/view-sc"},{"type":"link","label":"Error Handling","href":"/smart-contracts/guide/solo/error-handling","docId":"guide/solo/error-handling"},{"type":"link","label":"Account Balances","href":"/smart-contracts/guide/solo/balances","docId":"guide/solo/balances"},{"type":"link","label":"Sending tokens to a Smart Contract","href":"/smart-contracts/guide/solo/sending-funds","docId":"guide/solo/sending-funds"},{"type":"link","label":"Return of tokens in case of failure","href":"/smart-contracts/guide/solo/reimbursed-funds","docId":"guide/solo/reimbursed-funds"},{"type":"link","label":"Sending tokens from ISCP to the Tangle","href":"/smart-contracts/guide/solo/sending-funds-sc","docId":"guide/solo/sending-funds-sc"}],"collapsible":true,"collapsed":true}],"collapsible":true,"collapsed":true},{"type":"category","label":"ISCP Chains and Nodes","items":[{"type":"link","label":"Running a Node","href":"/smart-contracts/guide/chains_and_nodes/running-a-node","docId":"guide/chains_and_nodes/running-a-node"},{"type":"link","label":"Using Docker (Standalone)","href":"/smart-contracts/guide/chains_and_nodes/docker_standalone","docId":"guide/chains_and_nodes/docker_standalone"},{"type":"link","label":"Configuring wasp-cli","href":"/smart-contracts/guide/chains_and_nodes/wasp-cli","docId":"guide/chains_and_nodes/wasp-cli"},{"type":"link","label":"Setting Up a Chain","href":"/smart-contracts/guide/chains_and_nodes/setting-up-a-chain","docId":"guide/chains_and_nodes/setting-up-a-chain"},{"type":"link","label":"Chain Management","href":"/smart-contracts/guide/chains_and_nodes/chain-management","docId":"guide/chains_and_nodes/chain-management"},{"type":"link","label":"Testnet","href":"/smart-contracts/guide/chains_and_nodes/testnet","docId":"guide/chains_and_nodes/testnet"}],"collapsible":true,"collapsed":true},{"type":"category","label":"Wasm VM","items":[{"type":"category","label":"Introduction","items":[{"type":"link","label":"Wasm VM for ISCP","href":"/smart-contracts/guide/wasm_vm/intro","docId":"guide/wasm_vm/intro"},{"type":"link","label":"Data Access Proxies","href":"/smart-contracts/guide/wasm_vm/proxies","docId":"guide/wasm_vm/proxies"},{"type":"link","label":"WasmLib Data Types","href":"/smart-contracts/guide/wasm_vm/types","docId":"guide/wasm_vm/types"},{"type":"link","label":"Function Call Context","href":"/smart-contracts/guide/wasm_vm/context","docId":"guide/wasm_vm/context"}],"collapsible":true,"collapsed":true},{"type":"category","label":"Schema tool","items":[{"type":"link","label":"Smart Contract Schema Tool","href":"/smart-contracts/guide/schema/","docId":"guide/schema/schema"},{"type":"link","label":"Using the Schema Tool","href":"/smart-contracts/guide/schema/usage","docId":"guide/schema/usage"},{"type":"link","label":"Structured Data Types","href":"/smart-contracts/guide/schema/structs","docId":"guide/schema/structs"},{"type":"link","label":"Type Definitions","href":"/smart-contracts/guide/schema/typedefs","docId":"guide/schema/typedefs"},{"type":"link","label":"Smart Contract State","href":"/smart-contracts/guide/schema/state","docId":"guide/schema/state"},{"type":"link","label":"Triggering Events","href":"/smart-contracts/guide/schema/events","docId":"guide/schema/events"},{"type":"link","label":"Function Definitions","href":"/smart-contracts/guide/schema/funcs","docId":"guide/schema/funcs"},{"type":"link","label":"Limiting Access","href":"/smart-contracts/guide/schema/access","docId":"guide/schema/access"},{"type":"link","label":"Function Parameters","href":"/smart-contracts/guide/schema/params","docId":"guide/schema/params"},{"type":"link","label":"Function Results","href":"/smart-contracts/guide/schema/results","docId":"guide/schema/results"},{"type":"link","label":"Thunk Functions","href":"/smart-contracts/guide/schema/thunks","docId":"guide/schema/thunks"},{"type":"link","label":"View-Only Functions","href":"/smart-contracts/guide/schema/views","docId":"guide/schema/views"},{"type":"link","label":"Smart Contract Initialization","href":"/smart-contracts/guide/schema/init","docId":"guide/schema/init"},{"type":"link","label":"Token Transfers","href":"/smart-contracts/guide/schema/transfers","docId":"guide/schema/transfers"},{"type":"link","label":"Function Descriptors","href":"/smart-contracts/guide/schema/funcdesc","docId":"guide/schema/funcdesc"},{"type":"link","label":"Calling Functions","href":"/smart-contracts/guide/schema/call","docId":"guide/schema/call"},{"type":"link","label":"Posting Asynchronous Requests","href":"/smart-contracts/guide/schema/post","docId":"guide/schema/post"},{"type":"link","label":"Testing Smart Contracts","href":"/smart-contracts/guide/schema/test","docId":"guide/schema/test"},{"type":"link","label":"Example Tests","href":"/smart-contracts/guide/schema/examples","docId":"guide/schema/examples"},{"type":"link","label":"Colored Tokens and Time Locks","href":"/smart-contracts/guide/schema/timelock","docId":"guide/schema/timelock"}],"collapsible":true,"collapsed":true}],"collapsible":true,"collapsed":true},{"type":"category","label":"EVM","items":[{"type":"link","label":"Introduction","href":"/smart-contracts/guide/evm/introduction","docId":"guide/evm/introduction"},{"type":"link","label":"Limitations","href":"/smart-contracts/guide/evm/limitations","docId":"guide/evm/limitations"},{"type":"link","label":"Creating a Chain","href":"/smart-contracts/guide/evm/create-chain","docId":"guide/evm/create-chain"},{"type":"link","label":"Tooling","href":"/smart-contracts/guide/evm/tooling","docId":"guide/evm/tooling"},{"type":"category","label":"Examples","items":[{"type":"link","label":"Example Contract","href":"/smart-contracts/guide/evm/examples/introduction","docId":"guide/evm/examples/introduction"},{"type":"link","label":"ERC20","href":"/smart-contracts/guide/evm/examples/ERC20","docId":"guide/evm/examples/ERC20"}],"collapsible":true,"collapsed":true}],"collapsible":true,"collapsed":true},{"type":"category","label":"Example projects","items":[{"type":"link","label":"Fair Roulette","href":"/smart-contracts/guide/example_projects/fair_roulette","docId":"guide/example_projects/fair_roulette"}],"collapsible":true,"collapsed":true},{"type":"category","label":"Development tools","items":[{"type":"link","label":"Preconfigured Development Docker setup","href":"/smart-contracts/guide/development_tools/docker_preconfigured","docId":"guide/development_tools/docker_preconfigured"}],"collapsible":true,"collapsed":true},{"type":"link","label":"Contribute","href":"/smart-contracts/contribute","docId":"contribute"},{"type":"link","label":"Metrics","href":"/smart-contracts/metrics","docId":"metrics"}]},"docs":{"contribute":{"id":"contribute","title":"Contributing","description":"How to contribute to IOTA Smart Contracts. Creating a PR, setting up golangci-lint.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/chain-management":{"id":"guide/chains_and_nodes/chain-management","title":"Chain Management","description":"How to manage a chain using the Grafana dashboard, a client to receive published events, logging and validators.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/docker_standalone":{"id":"guide/chains_and_nodes/docker_standalone","title":"Docker (Standalone)","description":"How to run a Wasp node in using Docker. Build the image, configure it, run it.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/publisher":{"id":"guide/chains_and_nodes/publisher","title":"Wasp Publisher","description":"Publishing important events via a Nanomsg message stream. Subscribing to a stream with a client. Message format description."},"guide/chains_and_nodes/running-a-node":{"id":"guide/chains_and_nodes/running-a-node","title":"Running a Node","description":"How to run a node. Requirements, configuration parameters, dashboard configuration and tests.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/setting-up-a-chain":{"id":"guide/chains_and_nodes/setting-up-a-chain","title":"Setting Up a Chain","description":"Setting up a chain requirements, configuration parameters, validators and tests.","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/testnet":{"id":"guide/chains_and_nodes/testnet","title":"Testnet","description":"A public testnet for developers to try out smart contracts","sidebar":"tutorialSidebar"},"guide/chains_and_nodes/wasp-cli":{"id":"guide/chains_and_nodes/wasp-cli","title":"Configuring wasp-cli","description":"How to configure the wasp-cli. Requirements and configuration parameters.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/how-accounts-work":{"id":"guide/core_concepts/accounts/how-accounts-work","title":"How Accounts Work","description":"IOTA Smart Contracts chains keeps a ledger of on-chain account balances.  ON-chain accounts are identified by an AgentID.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/how-to-deposit-to-a-chain":{"id":"guide/core_concepts/accounts/how-to-deposit-to-a-chain","title":"How to Deposit to a Chain","description":"The `deposit` entrypoint credits the transferred IOTAS into your on-chain account.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/how-to-withdraw-from-a-chain":{"id":"guide/core_concepts/accounts/how-to-withdraw-from-a-chain","title":"How to Withdraw From a Chain","description":"The `withdraw` endpoint sends funds owned by the callee to their L1 address.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/the-common-account":{"id":"guide/core_concepts/accounts/the-common-account","title":"The Common Account","description":"The common account is controlled by the chain owner, and is used to store funds collected by fees, invalid contracts or sent to the L1 chain address.","sidebar":"tutorialSidebar"},"guide/core_concepts/accounts/view-account-balances":{"id":"guide/core_concepts/accounts/view-account-balances","title":"View Account Balances","description":"The Accounts contract provides the balance, totalAssets and accounts views.","sidebar":"tutorialSidebar"},"guide/core_concepts/consensus":{"id":"guide/core_concepts/consensus","title":"Consensus","description":"IOTA Smart Contracts Consensus","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/accounts":{"id":"guide/core_concepts/core_contracts/accounts","title":"The `accounts` Contract","description":"The `accounts` contract keeps a consistent ledger of on-chain accounts in its state for the agents that control them. There are two types of agents who can do it, L1 addresses and smart contracts.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/blob":{"id":"guide/core_concepts/core_contracts/blob","title":"The `blob` Contract","description":"The `blobs` contract maintains a registry of _blobs_ (a collection of arbitrary binary data) which are referenced from smart contracts via their hashes.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/blocklog":{"id":"guide/core_concepts/core_contracts/blocklog","title":"The `blocklog` Contract","description":"The `blocklog` contract is to keep track of the blocks of requests that were processed by the chain. It also provides views to get request status, receipts, block information, or events.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/default":{"id":"guide/core_concepts/core_contracts/default","title":"The `_default` Contract","description":"The function of the `_default` contract is to provide a fall-back target for any request that cannot be handled by the chain, or contract, it was addressed to","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/governance":{"id":"guide/core_concepts/core_contracts/governance","title":"The `governance` Contract","description":"The `governance` contract defines the set of identities that constitute the state controller, who is the chain owner and  the fees for request execution.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/overview":{"id":"guide/core_concepts/core_contracts/overview","title":"Core Contracts","description":"There currently are 6 core smart contracts that are always deployed on each  chain, root, _default, accounts, blob, blocklog, and governance.","sidebar":"tutorialSidebar"},"guide/core_concepts/core_contracts/root":{"id":"guide/core_concepts/core_contracts/root","title":"The `root` Contract","description":"The root contract is the first smart contract deployed on the chain. It functions as a smart contract factory for the chain, and manages chain ownership and fees.","sidebar":"tutorialSidebar"},"guide/core_concepts/iscp":{"id":"guide/core_concepts/iscp","title":"IOTA Smart Contracts","description":"IOTA Smart Contracts are IOTA\'s solution for running smart contracts on top of the IOTA tangle. Wasp is the node software we\'ve built to let you run smart contracts in a committee using a virtual machine of choice."},"guide/core_concepts/iscp-architecture":{"id":"guide/core_concepts/iscp-architecture","title":"IOTA Smart Contracts Architecture","description":"IOTA Smart Contracts allow anyone to start their own chain and validators. Link to full technical description of the IOTA Smart Contarcts architecture and whitepaper","sidebar":"tutorialSidebar"},"guide/core_concepts/sandbox":{"id":"guide/core_concepts/sandbox","title":"Sandbox Interface","description":"Smart Contracts can only interact with the world by using the Sandbox interface which provides limited and deterministic access to the state through a key/value storage abstraction.","sidebar":"tutorialSidebar"},"guide/core_concepts/smart-contract-anatomy":{"id":"guide/core_concepts/smart-contract-anatomy","title":"Anatomy of a Smart Contract","description":"Each smart contract instance has a program with a collection of entry points and a state.","sidebar":"tutorialSidebar"},"guide/core_concepts/smart-contracts":{"id":"guide/core_concepts/smart-contracts","title":"Smart Contracts","description":"Smart contracts are applications you can trust that run on a distributed network with multiple validators all executing and validating the same code","sidebar":"tutorialSidebar"},"guide/core_concepts/smartcontract-interaction/off-ledger-requests":{"id":"guide/core_concepts/smartcontract-interaction/off-ledger-requests","title":"Off-ledger Requests","description":"An Off-ledger request is not a transaction, but it contains the same information as an on-ledger request, and it is cryptographically signed. This kind of requests do not rely on the Tangle for confirmation, so they are much faster.","sidebar":"tutorialSidebar"},"guide/core_concepts/smartcontract-interaction/on-ledger-requests":{"id":"guide/core_concepts/smartcontract-interaction/on-ledger-requests","title":"On-ledger Requests","description":"Requests to the smart contract as transactions on the Tangle are called on-ledger requests.","sidebar":"tutorialSidebar"},"guide/core_concepts/states":{"id":"guide/core_concepts/states","title":"State, Transitions, and State Anchoring","description":"The state of the chain consists of balances of native IOTA digital assets and a collection of key/value pairs which represents use case-specific data stored in the chain by its smart contracts outside the UTXO ledger.","sidebar":"tutorialSidebar"},"guide/core_concepts/validators":{"id":"guide/core_concepts/validators","title":"Validators","description":"Each chain is run by a network of validator nodes which run a consensus on the chain state update.","sidebar":"tutorialSidebar"},"guide/development_tools/docker_preconfigured":{"id":"guide/development_tools/docker_preconfigured","title":"Preconfigured Development Docker setup","description":"How to run the preconfigured Docker setup.","sidebar":"tutorialSidebar"},"guide/evm/create-chain":{"id":"guide/evm/create-chain","title":"Creating an EVM Chain","description":"Create, fund and deploy a new EVM Chain using IOTA Smart Contracts.","sidebar":"tutorialSidebar"},"guide/evm/examples/ERC20":{"id":"guide/evm/examples/ERC20","title":"ERC20 Example","description":"Solidity smart contract ERC20.","sidebar":"tutorialSidebar"},"guide/evm/examples/ERC721":{"id":"guide/evm/examples/ERC721","title":"ERC721 Example","description":"Create and deploy a Solidity smart contract to mint NFTs using the ERC721 standard."},"guide/evm/examples/introduction":{"id":"guide/evm/examples/introduction","title":"Solidity Smart Contract Example","description":"Solidity smart contract example.","sidebar":"tutorialSidebar"},"guide/evm/introduction":{"id":"guide/evm/introduction","title":"EVM/Solidity Based Smart Contracts","description":"The current release of IOTA Smart Contracts also has experimental support for EVM/Solidity,this means that existing smart contracts and tooling from other EVM based chains like Ethereum are fully compatible with EVM chains running on IOTA Smart Contracts.","sidebar":"tutorialSidebar"},"guide/evm/limitations":{"id":"guide/evm/limitations","title":"EVM Limitations within IOTA Smart Contracts","description":"EVM based smart contract limitations. The current implementation is fully sand-boxed and not aware of IOTA or IOTA Smart Contracts. You start an EVM chain with a new supply of EVM specific tokens assigned to a single address.","sidebar":"tutorialSidebar"},"guide/evm/tooling":{"id":"guide/evm/tooling","title":"EVM Tooling","description":"Existing EVM tooling is compatible and can be used directly with an IOTA Smart Contracts chain running EVM. You can configure hardhat, metamask, remix, Ether.js and Web3.js among others.","sidebar":"tutorialSidebar"},"guide/example_projects/fair_roulette":{"id":"guide/example_projects/fair_roulette","title":"Fair Roulette","description":"An example game project with frontend and contract, demonstrating the development, setup, and interaction with a smart contract.","sidebar":"tutorialSidebar"},"guide/schema/access":{"id":"guide/schema/access","title":"Limiting Access","description":"The optional access subsection indicates the agent who is allowed to access the function. When this definition is omitted, anyone is allowed to call the function.","sidebar":"tutorialSidebar"},"guide/schema/call":{"id":"guide/schema/call","title":"Calling Functions","description":"Synchronous calls can only be made between contracts that are running on the same contract chain. When calling a smart contract function you can only access the memory assigned to that specific smart contract, the only way to share data between smart contracts that call each other is through function parameters and return values.","sidebar":"tutorialSidebar"},"guide/schema/events":{"id":"guide/schema/events","title":"Triggering Events","description":"The smart contracts can trigger events that the user can subscribe to and that convey changes to its state.","sidebar":"tutorialSidebar"},"guide/schema/examples":{"id":"guide/schema/examples","title":"Example Tests","description":"Use the SoloContext to create full-blown tests for the dividend example smart contract.","sidebar":"tutorialSidebar"},"guide/schema/funcdesc":{"id":"guide/schema/funcdesc","title":"Function Descriptors","description":"The schema tool provides us with an easy way to access to smart contract functions through function descriptors, which allow you to initiate the function by calling it synchronously, or posting a request to run it asynchronously.","sidebar":"tutorialSidebar"},"guide/schema/funcs":{"id":"guide/schema/funcs","title":"Function Definitions","description":"The code generated for Funcs will be able to inspect and modify the smart contract state, whereas the code generated for Views will only be able to inspect the state.","sidebar":"tutorialSidebar"},"guide/schema/init":{"id":"guide/schema/init","title":"Smart Contract Initialization","description":"The init function will automatically be called immediately after the first time the contract has been deployed to the VM.  This is a one-time initialization call, meant to be performed by the contract deployment mechanism.","sidebar":"tutorialSidebar"},"guide/schema/params":{"id":"guide/schema/params","title":"Function Parameters","description":"The optional params subsection contains field definitions for each of the parameters that a function takes.","sidebar":"tutorialSidebar"},"guide/schema/post":{"id":"guide/schema/post","title":"Posting Asynchronous Requests","description":"Asynchronous function calls between smart contracts are posted as requests on the Tangle. They allow you to invoke any smart contract function that is not a View on any smart contract chain.","sidebar":"tutorialSidebar"},"guide/schema/results":{"id":"guide/schema/results","title":"Function Results","description":"The optional `results` subsection contains field definitions for each of the results a function produces. The layout of the field definitions is identical to that of the state field definitions","sidebar":"tutorialSidebar"},"guide/schema/schema":{"id":"guide/schema/schema","title":"Smart Contract Schema Tool","description":"To facilitate the code generation, we decided to use a _schema definition file_ for smart contracts. All aspects of a smart contract that should be known by someone who wants to use the contract are clearly defined in a schema definition file","sidebar":"tutorialSidebar"},"guide/schema/state":{"id":"guide/schema/state","title":"Smart Contract State","description":"The smart contract state storage on the host consists of a single key/value map, as long as you access the data in the same way that you used to store it, you will always get valid data back.","sidebar":"tutorialSidebar"},"guide/schema/structs":{"id":"guide/schema/structs","title":"Structured Data Types","description":"You can use structs directly as a type in state storage definitions and the schema tool will automatically generate the proxy code to access it properly.","sidebar":"tutorialSidebar"},"guide/schema/test":{"id":"guide/schema/test","title":"Testing Smart Contracts","description":"Testing of smart contracts happens in the Solo testing environment. This enables synchronous, deterministic testing of smart contract functionality without the overhead of having to start nodes, set up a committee, and send transactions over the Tangle","sidebar":"tutorialSidebar"},"guide/schema/thunks":{"id":"guide/schema/thunks","title":"Thunk Functions","description":"Thunk functions encapsulate access and parameter checking and set up the type-safe function-specific contexts. Thunks are used to insert operations at the beginning or end of the other function to adapt it to changing requirements","sidebar":"tutorialSidebar"},"guide/schema/timelock":{"id":"guide/schema/timelock","title":"Colored Tokens and Time Locks","description":"You can post a time-locked request by using the Delay() method. You can convert plan tokens to colored tokens using the Mint() method.","sidebar":"tutorialSidebar"},"guide/schema/transfers":{"id":"guide/schema/transfers","title":"Token Transfers","description":"There are two methods in the IOTA Smart Contracts function context that deal with token balances. The balances() method can be used to determine the current total balance per token color. The incoming() method can be used to determine the amounts of incoming tokens per token color that were sent with the request to call the smart contract function.","sidebar":"tutorialSidebar"},"guide/schema/typedefs":{"id":"guide/schema/typedefs","title":"Type Definitions","description":"You can add a typedefs section to the schema definition file, where you can define a single type name for a container type. This way you can easily create containers that contain container types.","sidebar":"tutorialSidebar"},"guide/schema/usage":{"id":"guide/schema/usage","title":"Using the Schema Tool","description":"The `schema` tool will assist in creating a smart contract unobtrusively as possible.","sidebar":"tutorialSidebar"},"guide/schema/views":{"id":"guide/schema/views","title":"View-Only Functions","description":"Views are smart contract functions that only allow you to retrieve state information about the smart contract. They have a special, limited IOTA Smart Contracts function context that does not allow them to change the smart contract state.","sidebar":"tutorialSidebar"},"guide/solo/balances":{"id":"guide/solo/balances","title":"Account Balances","description":"Smart contracts can exchange assets between themselves on the same chain and also between different chains, as well as with addresses on the UTXO Ledger.","sidebar":"tutorialSidebar"},"guide/solo/error-handling":{"id":"guide/solo/error-handling","title":"Error Handling","description":"Whatever happens during the execution of a smart contract\'s full entry point, processing of the request always results in the state transition.  The VM context catches exceptions (panics) in the program. Its consequences are recorded in the state of the chain during the fallback processing.","sidebar":"tutorialSidebar"},"guide/solo/first-example":{"id":"guide/solo/first-example","title":"First Example","description":"Example of a _Solo_ test. It deploys a new chain and invokes a function in the root contract.","sidebar":"tutorialSidebar"},"guide/solo/invoking-sc":{"id":"guide/solo/invoking-sc","title":"Invoking Smart Contracts","description":"In Solo, you can post an on-ledger request with a single call to PostRequestSync.  Alternatively, you can post an off-ledger request by using chain.PostRequestOffLedger instead of PostRequestSync.","sidebar":"tutorialSidebar"},"guide/solo/reimbursed-funds":{"id":"guide/solo/reimbursed-funds","title":"Return of Tokens in Case of Failure","description":"In case of panic in the smart contract for whatever reason, the fallback logic of the ISCP VM returns all tokens (minus fees) to the sender.","sidebar":"tutorialSidebar"},"guide/solo/sending-funds":{"id":"guide/solo/sending-funds","title":"Sending Tokens to a Smart Contract","description":"The creator of the smart contract (and nobody else) may withdraw iotas to its address by sending a `withdrawIotas` request.","sidebar":"tutorialSidebar"},"guide/solo/sending-funds-sc":{"id":"guide/solo/sending-funds-sc","title":"Sending Tokens From IOTA Smart Contracts to the Tangle","description":"Smart contract only allow their creator to withdraw tokens contained in the smart contract. If authorisation conditions are satisfied, the contract calls the transfer_to_address sandbox function to send all iotas, owned by the contract, to the caller\'s address.","sidebar":"tutorialSidebar"},"guide/solo/tokens-and-utxos":{"id":"guide/solo/tokens-and-utxos","title":"Tokens and the UTXO Ledger","description":"The UTXO Ledger contains balances of colored tokens locked in addresses.  You can only move tokens on the UTXO Ledger by unlocking the corresponding address with its private key","sidebar":"tutorialSidebar"},"guide/solo/view-sc":{"id":"guide/solo/view-sc","title":"Calling a View","description":"The basic principle of calling a view is similar to sending a request to the smart contract. The essential difference is that calling a view does not constitute an asynchronous transaction, it is just a direct synchronous call to the view entry point function, exposed by the smart contract.","sidebar":"tutorialSidebar"},"guide/solo/what-is-solo":{"id":"guide/solo/what-is-solo","title":"Solo","description":"Solo is a testing framework that allows developers to validate real smart contracts and entire inter-chain protocols","sidebar":"tutorialSidebar"},"guide/wasm_vm/context":{"id":"guide/wasm_vm/context","title":"Function Call Context","description":"The function call context provides as a predefined parameter to the smart contract function and allows you to access the functionality that the host sandbox interface provides.","sidebar":"tutorialSidebar"},"guide/wasm_vm/intro":{"id":"guide/wasm_vm/intro","title":"Introduction to the Wasm VM for IOTA Smart Contracts","description":"IOTA Smart Contracts provide a very flexible way of programming smart contracts by providing an API to a sandboxed environment that allows you to interact with IOTA Smart Contracts deterministically without any security risks.","sidebar":"tutorialSidebar"},"guide/wasm_vm/proxies":{"id":"guide/wasm_vm/proxies","title":"Data Access Proxies","description":"As there is no way for the Wasm code to access any memory outside its own memory space, the WasmLib interface provides a number of proxies to make accessing data within the IOTA Smart Contracts sandbox as seamless as possible.","sidebar":"tutorialSidebar"},"guide/wasm_vm/types":{"id":"guide/wasm_vm/types","title":"WasmLib Data Types","description":"The WasmLib provides direct support for the basic value data types that are found in all programming languages, and WasmLib version of IOTA Smart Contracts-specific value data types.","sidebar":"tutorialSidebar"},"metrics":{"id":"metrics","title":"Exposed Metrics","description":"You can see all exposed metrics on https://metrics.wasp.sc.iota.org.","sidebar":"tutorialSidebar"},"overview":{"id":"overview","title":"IOTA Smart Contracts","description":"IOTA Smart Contract Protocol is IOTA\'s solution for running smart contracts on top of the IOTA tangle.","sidebar":"tutorialSidebar"}}}')}}]);