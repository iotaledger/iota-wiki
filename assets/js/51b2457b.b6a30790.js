"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[69169],{91090:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return d},default:function(){return h},frontMatter:function(){return r},metadata:function(){return p},toc:function(){return u}});var a=n(87462),i=n(63366),s=(n(67294),n(3905)),o=n(31531),l=["components"],r={title:"Examples",description:"Official IOTA Client Library Software Node.js examples.",image:"/img/logo/iota_mark_light.png",keywords:["account","address","nodejs","message","output"]},d=void 0,p={unversionedId:"libraries/nodejs/examples",id:"libraries/nodejs/examples",title:"Examples",description:"Official IOTA Client Library Software Node.js examples.",source:"@site/content/build/iota.rs/production/documentation/docs/libraries/nodejs/examples.mdx",sourceDirName:"libraries/nodejs",slug:"/libraries/nodejs/examples",permalink:"/iota.rs/libraries/nodejs/examples",draft:!1,editUrl:"https://github.com/iotaledger/iota.rs/edit/production/documentation/content/build/iota.rs/production/documentation/docs/libraries/nodejs/examples.mdx",tags:[],version:"current",frontMatter:{title:"Examples",description:"Official IOTA Client Library Software Node.js examples.",image:"/img/logo/iota_mark_light.png",keywords:["account","address","nodejs","message","output"]},sidebar:"docs",previous:{title:"Getting Started With Node.js",permalink:"/iota.rs/libraries/nodejs/getting_started"},next:{title:"API Reference - IOTA Client Library - Node.js binding",permalink:"/iota.rs/libraries/nodejs/api_reference"}},c={},u=[{value:"Connecting to node(s)",id:"connecting-to-nodes",level:2},{value:"Generating seed and addresses",id:"generating-seed-and-addresses",level:2},{value:"Address/key space",id:"addresskey-space",level:3},{value:"Generating address(es)",id:"generating-addresses",level:3},{value:"Checking a balance",id:"checking-a-balance",level:2},{value:"Messages, payload and transactions",id:"messages-payload-and-transactions",level:2},{value:"Unspent Transaction Output (UTXO)",id:"unspent-transaction-output-utxo",level:3},{value:"Outputs",id:"outputs",level:2},{value:"Messages",id:"messages",level:2},{value:"IndexationPayload",id:"indexationpayload",level:3},{value:"SignedTransaction",id:"signedtransaction",level:3},{value:"Dust protection",id:"dust-protection",level:4},{value:"Listening to MQTT",id:"listening-to-mqtt",level:2}],m={toc:u};function h(e){var t=e.components,r=(0,i.Z)(e,l);return(0,s.kt)("wrapper",(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"It is not recommended to store passwords/seeds on host's environment variables or in the source code in a production setup! Please make sure you follow our ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/guides/backup_security"},"backup and security")," recommendations for production use!"))),(0,s.kt)("h2",{id:"connecting-to-nodes"},"Connecting to node(s)"),(0,s.kt)("p",null,"All features of ",(0,s.kt)("inlineCode",{parentName:"p"},"iota.rs")," library are accessible via an instance of ",(0,s.kt)("inlineCode",{parentName:"p"},"Client")," class that provides high-level abstraction to all interactions over IOTA network (Tangle). This class has to be instantiated before starting any interactions with the library, or more precisely with ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/node_software"},"IOTA nodes")," that power IOTA network."),(0,s.kt)("p",null,"In ",(0,s.kt)("inlineCode",{parentName:"p"},"nodejs")," binding, the ",(0,s.kt)("inlineCode",{parentName:"p"},"Client")," instance is instantiated and optionally configured via chaining calls of ",(0,s.kt)("inlineCode",{parentName:"p"},"ClientBuilder")," helper class."),(0,s.kt)("p",null,"The library is designed to automatically choose a starting IOTA node based on the network type one would like to participate in: ",(0,s.kt)("inlineCode",{parentName:"p"},"testnet")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"mainnet"),". So very simplistic example how to connect to ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/devnet"},"IOTA devnet")," is the following one:"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"\nfunction run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder()\n        .localPow(true)\n        .build();\n\n    client.getInfo().then(console.log).catch(console.error);\n}\n\nrun()\n"),(0,s.kt)("p",null,"Output example of ",(0,s.kt)("inlineCode",{parentName:"p"},"getInfo()")," function of the ",(0,s.kt)("inlineCode",{parentName:"p"},"ClientBuilder")," instance:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "nodeinfo":{\n      "name":"HORNET",\n      "version":"0.6.0-alpha",\n      "isHealthy":true,\n      "networkId":"migration",\n      "bech32HRP":"atoi",\n      "minPoWScore":100,\n      "messagesPerSecond":4.2,\n      "referencedMessagesPerSecond":4.1,\n      "referencedRate":97.61904761904762,\n      "latestMilestoneTimestamp":1618139001,\n      "latestMilestoneIndex":7092,\n      "confirmedMilestoneIndex":7092,\n      "pruningIndex":0,\n      "features":[\n         "PoW"\n      ]\n   },\n   "url":"https://api.lb-0.h.chrysalis-devnet.iota.cafe"\n}\n')),(0,s.kt)("p",null,"The most important properties:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"isHealthy"),': indicates whether the given node is in sync with the network and so it is safe to use it. Even if a node is up and running it may not be fully prepared to process your API calls properly. The node should be "synced", meaning should be aware of all TXs in the Tangle. It is better to avoid not fully synced nodes'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"bech32HRP"),": indicates whether the given node is a part of testnet (",(0,s.kt)("inlineCode",{parentName:"li"},"atoi"),") or mainnet (",(0,s.kt)("inlineCode",{parentName:"li"},"iota"),"). See more info regarding ",(0,s.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom"},"IOTA address format"))),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Please note, when using node load balancers then mentioned health check may be quite useless since follow-up API calls may be served by different node behind the load balancer that may have not been actually checked. One should be aware of this fact and trust the given load balancer participates only with nodes that are in healthy state. ",(0,s.kt)("inlineCode",{parentName:"em"},"iota.rs")," library additionally supports a management of internal node pool and so load-balancer-like behavior can be mimicked using this feature locally.")),(0,s.kt)("p",null,"Needless to say, the ",(0,s.kt)("inlineCode",{parentName:"p"},"ClientBuilder")," helper class provides several chaining calls via which the process can be closely managed."),(0,s.kt)("p",null,"The most common ones:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},".network(str)"),": can be ",(0,s.kt)("inlineCode",{parentName:"li"},"testnet")," or ",(0,s.kt)("inlineCode",{parentName:"li"},"mainnet"),". It instructs the library whether to automatically select testnet nodes or mainnet nodes"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},".node(url)"),": specify address of actual running IOTA node that should be used to communicate with (in format ",(0,s.kt)("inlineCode",{parentName:"li"},"https://node:port"),"), for ex: ",(0,s.kt)("a",{parentName:"li",href:"https://api.lb-0.h.chrysalis-devnet.iota.cafe:443"},"https://api.lb-0.h.chrysalis-devnet.iota.cafe:443")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},".nodePoolUrls(urls)"),": library also supports a management of pool of nodes. You can provide a list of nodes and library manages access to them automatically (selecting them based on their sync status)"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},".localPow(bool)"),": ",(0,s.kt)("inlineCode",{parentName:"li"},".localPow (True)")," (by default) means a ",(0,s.kt)("inlineCode",{parentName:"li"},"Proof-of-work")," is done locally and not remotely"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},".disableNodeSync()"),": when called, it means library also uses nodes that ",(0,s.kt)("em",{parentName:"li"},"are not")," in sync with network. This parameter is usually useful if one would like to interact with local test node that is not fully synced. This parameter should not be used in production")),(0,s.kt)("p",null,"If ",(0,s.kt)("inlineCode",{parentName:"p"},".nodePoolUrls(urls)")," is provided then the library periodically checks in some interval (call ",(0,s.kt)("inlineCode",{parentName:"p"},".nodeSyncInterval(interval)"),") whether node is in sync or not."),(0,s.kt)("p",null,"Example of use of additional initialization chaining calls, such as leveraging a custom node:"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"\nfunction run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder()\n        .node('https://api.lb-0.h.chrysalis-devnet.iota.cafe:443')    // custom node\n        .localPow(true)                                         // pow is done locally\n        .disableNodeSync()                                      // even non-synced node is fine - do not use in production\n        .build();\n\n    client.getInfo().then(console.log).catch(console.error);\n}\n\nrun()\n"),(0,s.kt)("h2",{id:"generating-seed-and-addresses"},"Generating seed and addresses"),(0,s.kt)("p",null,"Since the IOTA network is a permission-less type of network, anybody is able to use it and interact with it. No central authority is required at any stage. So anybody is able to generate their own ",(0,s.kt)("inlineCode",{parentName:"p"},"seed")," and then deterministically generate respective private keys/addresses."),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Please note, it is highly recommended to NOT use online seed generators at all. The seed is the only key to the given addresses. Anyone who owns the seed also owns all funds related to respective IOTA addresses (all of them)."))),(0,s.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"We strongly recommend to use the official ",(0,s.kt)("inlineCode",{parentName:"p"},"wallet.rs")," library together with ",(0,s.kt)("inlineCode",{parentName:"p"},"stronghold.rs")," enclave for value-based transfers. This combination incorporates the best security practices while dealing with seeds, related addresses and ",(0,s.kt)("inlineCode",{parentName:"p"},"UTXO"),". See more information on ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/wallet.rs/welcome"},"Chrysalis docs"),"."))),(0,s.kt)("p",null,"IOTA uses ",(0,s.kt)("inlineCode",{parentName:"p"},"Ed25519")," signature scheme and address is usually represented by Bech32 (checksummed base32) format string of 64 characters."),(0,s.kt)("p",null,"A root of ",(0,s.kt)("inlineCode",{parentName:"p"},"Ed25519")," signature scheme is basically a ",(0,s.kt)("inlineCode",{parentName:"p"},"32-byte (256-bit)")," uniformly randomly generated seed based on which all private keys and corresponding addresses are generated. In the examples below, the seed is represented by a string of 64 characters using ",(0,s.kt)("inlineCode",{parentName:"p"},"[0-9a-f]")," alphabet (32 bytes encoded in hexadecimal)."),(0,s.kt)("p",null,"A seed can be, for example, generated using the SHA256 algorithm on some random input generated by a cryptographically secure pseudo-random generator, such as ",(0,s.kt)("inlineCode",{parentName:"p"},"crypto.randomBytes()"),":"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"function run() {\n    const crypto = require('crypto');\n    const seed = crypto.createHash('sha256').update(crypto.randomBytes(256)).digest('hex');\n    console.log(seed);\n\n    const { ClientBuilder } = require('@iota/client');\n    const client = new ClientBuilder().build();\n\n    const mnemonic = client.generateMnemonic();\n    console.log(mnemonic);\n\n    const hexEncodedSeed = client.mnemonicToHexSeed(mnemonic);\n    console.log(hexEncodedSeed);\n}\n\nrun()\n"),(0,s.kt)("p",null,"Output example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-plaintext"},"39bccf7b88a8017e6a96e6f31e34f138829c574dc6061523e84c5f2e53f5ca36\npass phrase weapon yellow diary scissors gift drive strategy antique scheme make surround aerobic mystery coral hope lock walnut become exclude only glove syrup\neff5c97c96ddab55d6fe78f914508750152eaab1b9692236bc79268895ecfd168e91eedd2489ed6c51fc44156b9a2e6c967e4edcfb649ff33d41581be4627347\n")),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"In modern wallet implementations, such as our ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/wallet.rs/welcome"},"wallet.rs library")," and ",(0,s.kt)("a",{parentName:"p",href:"https://blog.iota.org/firefly-beta-release/"},"firefly wallet"),", the seed is usually generated from a ",(0,s.kt)("inlineCode",{parentName:"p"},"seed mnemonic")," (",(0,s.kt)("inlineCode",{parentName:"p"},"seed phrase"),"), using ",(0,s.kt)("a",{parentName:"p",href:"https://en.bitcoin.it/wiki/BIP_0039"},"BIP39 standard"),", to be better memorized/stored by humans. It is based on a randomly generated list of english words and later used to generate the seed. Either way, the seed is a root for all generated private keys and addresses."))),(0,s.kt)("h3",{id:"addresskey-space"},"Address/key space"),(0,s.kt)("p",null,"Before an actual address generation process, let's quickly focus on the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki"},"BIP32")," standard that describes an approach to ",(0,s.kt)("em",{parentName:"p"},"Hierarchical Deterministic Wallets"),". The standard was improved by ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki"},"BIP44")," lately."),(0,s.kt)("p",null,"These standards define a tree structure as a base for address and key space generation which is represented by a ",(0,s.kt)("inlineCode",{parentName:"p"},"derivation path"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-plaintext"},"m / purpose / coin_type / account / change / address_index\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"m"),": a master node (seed)"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"purpose"),": a constant which is {44}"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"coin_type"),": a constant set for each crypto currency. IOTA = 4218, for instance."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"account"),": account index. Zero-based increasing ",(0,s.kt)("inlineCode",{parentName:"li"},"int"),". This level splits the address/key space into independent branches (ex. user identities) which each has own set of addresses/keys"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"change"),": change index which is ",(0,s.kt)("inlineCode",{parentName:"li"},"{0, 1}"),", also known as ",(0,s.kt)("inlineCode",{parentName:"li"},"wallet chain"),".",(0,s.kt)("br",null),"\nThere are two independent chains of addresses/keys. ",(0,s.kt)("inlineCode",{parentName:"li"},"0")," is reserved for public addresses (for coin receival) and ",(0,s.kt)("inlineCode",{parentName:"li"},"1")," is reserved for internal (also known as change) addresses to which transaction change is returned. ",(0,s.kt)("em",{parentName:"li"},"IOTA is totally fine with address reuse, and so it is, technically speaking, totally valid to return transaction change to the same originating address. So it is up to developers whether to leverage it or not. ",(0,s.kt)("inlineCode",{parentName:"em"},"iota.rs")," library and its sibling ",(0,s.kt)("inlineCode",{parentName:"em"},"wallet.rs")," help with either scenario")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"address_index"),": address index. Zero-based increasing ",(0,s.kt)("inlineCode",{parentName:"li"},"int")," that indicates an address index")),(0,s.kt)("p",null,"As outlined, there is a quite large address/key space that is secured by a single unique seed."),(0,s.kt)("p",null,"And there are few additional interesting notes:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Each level defines a completely different subtree (subspace) of addresses/keys and those are never mixed up"),(0,s.kt)("li",{parentName:"ul"},'The hierarchy is ready to "absorb" addresses/keys for many different coins at the same time (',(0,s.kt)("inlineCode",{parentName:"li"},"coin_type"),"), and all those coins are secured by the same seed.",(0,s.kt)("br",null),"(So basically any BIP32/44-compliant wallet is potentially able to manage any BIP32/44-compliant coin(s))"),(0,s.kt)("li",{parentName:"ul"},"There may be also other ",(0,s.kt)("inlineCode",{parentName:"li"},"purposes")," in the future, however, let's consider a single purpose for now. The constant ",(0,s.kt)("inlineCode",{parentName:"li"},"44")," stands for BIP44"),(0,s.kt)("li",{parentName:"ul"},"The standard was agreed upon different crypto communities, although not all ",(0,s.kt)("inlineCode",{parentName:"li"},"derivation path")," components are always in active use. For example, ",(0,s.kt)("inlineCode",{parentName:"li"},"account")," is not always actively leveraged across crypto space (if this is the case then ",(0,s.kt)("inlineCode",{parentName:"li"},"account=0")," is usually used)"),(0,s.kt)("li",{parentName:"ul"},"Using different ",(0,s.kt)("inlineCode",{parentName:"li"},"accounts")," may be useful to split addresses/keys into some independent spaces and it is up to developers to implement.",(0,s.kt)("br",null),(0,s.kt)("em",{parentName:"li"},"Please note, it may have a negative impact on a performance while ",(0,s.kt)("a",{parentName:"em",href:"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#account-discovery"},"account discovery")," phase. So if you are planning on using many multiple accounts then you may be interested in our stateful library ",(0,s.kt)("a",{parentName:"em",href:"https://wiki.iota.org/wallet.rs/welcome"},"wallet.rs")," that incorporates all business logic needed to efficiently manage independent accounts. Also our ",(0,s.kt)("a",{parentName:"em",href:"https://wiki.iota.org/docs/build/exchange-integration/exchange-integration-guide"},"exchange guide")," provides some useful tips on how different accounts may be leveraged"))),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"address_generation",src:n(93965).Z,width:"1280",height:"720"})),(0,s.kt)("p",null,"So in case of IOTA, the derivation path of address/key space is ",(0,s.kt)("inlineCode",{parentName:"p"},"[seed]/44/4218/{int}/{0,1}/{int}"),". The levels ",(0,s.kt)("inlineCode",{parentName:"p"},"purpose")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"coin_type")," are given, the rest levels are up to developers to integrate."),(0,s.kt)("h3",{id:"generating-addresses"},"Generating address(es)"),(0,s.kt)("p",null,"IOTA addresses are generated via ",(0,s.kt)("inlineCode",{parentName:"p"},"AddressGetter")," helper class by calling the ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.getAddresses()")," function and respective chaining calls that return a list of tuples with generated addresses. Considering the previous chapter about individual address/key spaces, it becomes quite clear what all used input function arguments are for."),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Please note: for the examples outlined below, an example seed ",(0,s.kt)("inlineCode",{parentName:"em"},"b3d7092195c36d47133ff786d4b0a1ef2ee6a0052f6e87b6dc337935c70c531e")," was used via environment variable called ",(0,s.kt)("inlineCode",{parentName:"em"},"IOTA_SEED_SECRET"),". This seed serves for training purposes only.")),(0,s.kt)("p",null,"The whole process is deterministic which means the output is the same as long as the seed is the same:"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n  const { ClientBuilder } = require('@iota/client');\n\n  // Get the seed from environment variable\n  const IOTA_SEED_SECRET = process.env.IOTA_SEED_SECRET;\n\n  // client will connect to testnet by default\n  const client = new ClientBuilder().build();\n\n  const addresses = await client.getAddresses(IOTA_SEED_SECRET)\n    .accountIndex(0)\n    .range(0, 5)\n    .get();\n\n  console.log(addresses);\n}\n\nrun()\n"),(0,s.kt)("p",null,"Output example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-string"},"[\n  'atoi1qz6dr6dtl0856tf0pczz7gesrf7j8a4vr00q58ld2zx7ttlv3p96snpym9z',\n  'atoi1qpp7sz28a0ghvd6knwnljr7j2s04qquduuc5vlz94fwf94zznj2yv5ew2c4',\n  'atoi1qzje6zhg5vu456eg3z84ekcfn3laxqyczche5eeqhcdh3w9yr5sqvr4z4td',\n  'atoi1qqwhxjmcvmatpedeedapgx0vwyupfwx9k5n4w0lnc5l6vmz78aavwhs55v0',\n  'atoi1qzg63t9880jtfysvpq7rrynz0rqt3kd2fw8r4934ezraz9dpwvzxkw2dtmh'\n]\n")),(0,s.kt)("p",null,"IOTA addresses are represented by a checksumed base-32 string (Bech32) and you can see a detailed explanation on ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom"},"Chrysalis docs"),".\nJust a recap:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If an address starts with ",(0,s.kt)("inlineCode",{parentName:"li"},"atoi")," then it means it is related to ",(0,s.kt)("inlineCode",{parentName:"li"},"testnet"),". ",(0,s.kt)("inlineCode",{parentName:"li"},"iota")," stands for mainnet"),(0,s.kt)("li",{parentName:"ul"},"Number ",(0,s.kt)("inlineCode",{parentName:"li"},"1")," at 5",(0,s.kt)("sup",null,"th")," position is just a separator"),(0,s.kt)("li",{parentName:"ul"},"The last 6 characters are reserved for a checksum")),(0,s.kt)("p",null,"Addresses can be also represented in a hex format and luckily ",(0,s.kt)("inlineCode",{parentName:"p"},"iota.rs")," provides some convenience functions to convert addresses respectively: ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.bech32ToHex(bech32)")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.hexToBech32(hex, bech32_hrp (optional))"),"."),(0,s.kt)("p",null,"To quickly validate any IOTA address, there is a convenience function ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.isAddressValid()")," that returns a ",(0,s.kt)("inlineCode",{parentName:"p"},"bool")," value. Needless to say, performing a sanity check of an address before its use is an advisable practice."),(0,s.kt)("h2",{id:"checking-a-balance"},"Checking a balance"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"In the Chrysalis testnet, there is a faucet service that provides test tokens to any testnet address: ",(0,s.kt)("a",{parentName:"em",href:"https://faucet.chrysalis-devnet.iota.cafe/"},"https://faucet.chrysalis-devnet.iota.cafe/"))),(0,s.kt)("p",null,"There are three common api calls that can be leveraged:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Client.getAddressBalance(str)"),": it expects a single address in Bech32 format and returns ",(0,s.kt)("inlineCode",{parentName:"li"},"dict")," with a balance for the address"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Client.getAddressBalances([])"),": a convenience function that expects ",(0,s.kt)("inlineCode",{parentName:"li"},"list")," of addresses in Bech32 format and returns list of ",(0,s.kt)("inlineCode",{parentName:"li"},"dict")," with balances for all given addresses"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Client.getBalance(seed)"),": a convenience helper ",(0,s.kt)("inlineCode",{parentName:"li"},"BalanceGetter")," class that combines ",(0,s.kt)("inlineCode",{parentName:"li"},"Client.getAddresses()")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"Client.getAddressBalance()")," api calls. It returns a combined balance for the provided ",(0,s.kt)("inlineCode",{parentName:"li"},"seed")," and optional chaining calls ",(0,s.kt)("inlineCode",{parentName:"li"},".accountIndex(index)"),", ",(0,s.kt)("inlineCode",{parentName:"li"},".initialAddressIndex(index)")," and ",(0,s.kt)("inlineCode",{parentName:"li"},".gapLimit(amount)"))),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},'async function run() {\n    const { ClientBuilder } = require(\'@iota/client\');\n\n    // Get the seed from environment variable\n    const IOTA_SEED_SECRET = process.env.IOTA_SEED_SECRET;\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    // Get the balance of a single known address\n    console.log(\n        await client.getAddressBalance("atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86")\n    );\n\n    // Get the balance of addresses from an account\n    const balance = await client.getBalance(IOTA_SEED_SECRET)\n        .accountIndex(0)\n        .initialAddressIndex(0)\n        .get();\n\n    console.log("Account balance: " + balance);\n}\n\nrun()\n'),(0,s.kt)("p",null,"Example of output:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "address":"atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86",\n   "balance":10000000,\n   "dustAllowed":false\n}\nAccount balance: 0\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"dustAllowed")," indicates whether the given address is allowed to accept a dust due to ",(0,s.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/faq#what-is-dust-protection-and-how-does-it-work"},"dust protection mechanism"))),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"Client.getBalance(seed)")," performs a several tasks under the hood.\nIt starts generating addresses for the provided ",(0,s.kt)("inlineCode",{parentName:"p"},"seed")," and ",(0,s.kt)("inlineCode",{parentName:"p"},".accountIndex")," from ",(0,s.kt)("inlineCode",{parentName:"p"},".initialAddressIndex(index)"),", and checks for a balance of each of the generated addresses. Since it does not know how many addresses are used in fact, there is a condition set by the ",(0,s.kt)("inlineCode",{parentName:"p"},".gapLimit(amount)")," argument to know when to stop searching. If the ",(0,s.kt)("inlineCode",{parentName:"p"},".gapLimit")," amount of addresses in a row have no balance, the function returns results and searching does not continue."),(0,s.kt)("h2",{id:"messages-payload-and-transactions"},"Messages, payload and transactions"),(0,s.kt)("p",null,"Before we continue, let's introduce some additional terms that describe a unit that is actually broadcasted in the IOTA network. IOTA is based on a concept of ",(0,s.kt)("inlineCode",{parentName:"p"},"messages")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"payloads"),"."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"Message")," is a data structure that is actually being broadcasted in the IOTA network and represents a node (vertex) in the Tangle graph. It can refer to up to 8 previous messages and once a message is attached to the Tangle and approved by a milestone, the Tangle structure ensures the content of the message is unaltered. Every message is referenced by ",(0,s.kt)("inlineCode",{parentName:"p"},"message_id")," which is based on a hash algorithm of binary content of the message. ",(0,s.kt)("inlineCode",{parentName:"p"},"Message")," is an atomic unit that is confirmed by the network as a whole."),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"IOTA is no longer based on ternary. IOTA 1.5 (Chrysalis) uses binary to encode and broadcast all underlying data entities"))),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"Message")," is broadcasted using a binary format, is arbitrary in size (up to 32 kB), and it can hold variable sets of information so called ",(0,s.kt)("inlineCode",{parentName:"p"},"payloads"),". The number of payloads a single message can encapsulate is not given (even a message without any ",(0,s.kt)("inlineCode",{parentName:"p"},"payload")," at all is completely valid)."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"Payload")," represents a layer of concern. Some payloads may change a state of the ledger (ex. ",(0,s.kt)("inlineCode",{parentName:"p"},"transactions"),") and some may provide extra features to some specific applications and business use cases (ex. ",(0,s.kt)("inlineCode",{parentName:"p"},"indexed data"),")."),(0,s.kt)("p",null,"There are already implemented core payloads, such as ",(0,s.kt)("inlineCode",{parentName:"p"},"SignedTransaction"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"MilestonePayload")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"IndexationPayload")," but the message and payload definition is generic enough to incorporate any future payload(s) the community agrees upon."),(0,s.kt)("p",null,"Needless to say, the IOTA network ensures the outer structure of a message itself is valid and definitely aligned with a network consensus protocol, however the inner structure is very flexible, future-proof, and offers unmatched network extensibility."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"messages_in_tangle",src:n(69942).Z,width:"1112",height:"451"})),(0,s.kt)("p",null,"The current IOTA network incorporates the following core payloads:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"SignedTransaction"),": payload that describes ",(0,s.kt)("inlineCode",{parentName:"li"},"UTXO")," transactions that are the cornerstone of value-based transfers in the IOTA network. Via this payload, ",(0,s.kt)("inlineCode",{parentName:"li"},"message")," can be also cryptographically signed"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"MilestonePayload"),": payload that is emitted by Coordinator"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"IndexationPayload"),": payload that enables addition of an index to the encapsulating message, as well as some arbitrary data. The given index can be later used to search the message(s)")),(0,s.kt)("h3",{id:"unspent-transaction-output-utxo"},"Unspent Transaction Output (UTXO)"),(0,s.kt)("p",null,"IOTA uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"unspent transaction output")," model, so called ",(0,s.kt)("inlineCode",{parentName:"p"},"UTXO"),". It is based on an idea to track unspent amount of tokens via a data structure called ",(0,s.kt)("inlineCode",{parentName:"p"},"output"),"."),(0,s.kt)("p",null,"Simplified analogy:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"There are 100 tokens recorded in the ledger as ",(0,s.kt)("inlineCode",{parentName:"li"},"Output A")," and this output belongs to Alice. So ",(0,s.kt)("strong",{parentName:"li"},"initial state of ledger"),": ",(0,s.kt)("inlineCode",{parentName:"li"},"Output A")," = 100 tokens"),(0,s.kt)("li",{parentName:"ul"},"Alice sends 20 tokens to Paul, 30 tokens to Linda and keeps 50 tokens at her disposal"),(0,s.kt)("li",{parentName:"ul"},"Her 100 tokens are recorded as ",(0,s.kt)("inlineCode",{parentName:"li"},"Output A")," and so she has to divide (spent) tokens and create three new outputs:",(0,s.kt)("br",null),(0,s.kt)("inlineCode",{parentName:"li"},"Output B")," with 20 tokens that goes to Paul, ",(0,s.kt)("inlineCode",{parentName:"li"},"Output C")," with 30 tokens that goes to Linda and finally ",(0,s.kt)("inlineCode",{parentName:"li"},"Output D")," with the remaining 50 tokens that she keep for herself"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Original ",(0,s.kt)("inlineCode",{parentName:"strong"},"Output A"))," was completely spent and can't be used any more. It has been spent and so it ",(0,s.kt)("strong",{parentName:"li"},"becomes irrelevant")," to the ledger state"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"New state of ledger"),": ",(0,s.kt)("inlineCode",{parentName:"li"},"Output B")," = 20 tokens, ",(0,s.kt)("inlineCode",{parentName:"li"},"Output C")," = 30 tokens and ",(0,s.kt)("inlineCode",{parentName:"li"},"Output D")," = 50 tokens"),(0,s.kt)("li",{parentName:"ul"},"Total supply remains the same. Just the number of outputs differ and some outputs were replaced by other outputs in the process")),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"utxo",src:n(80441).Z,width:"1280",height:"400"})),(0,s.kt)("p",null,"The key takeaway of the outlined process is the fact that each unique ",(0,s.kt)("inlineCode",{parentName:"p"},"output")," can be spent ",(0,s.kt)("strong",{parentName:"p"},"only once"),". Once the given ",(0,s.kt)("inlineCode",{parentName:"p"},"output")," is spent, it can't be used any more and is irrelevant in regards to the ledger state."),(0,s.kt)("p",null,"So even if Alice still wants to keep the remaining tokens at her fingertips, those tokens have to be moved to completely new ",(0,s.kt)("inlineCode",{parentName:"p"},"output")," that can be, for instance, still tied to Alice's same iota address as before."),(0,s.kt)("p",null,"Every ",(0,s.kt)("inlineCode",{parentName:"p"},"output")," also stores information about an IOTA address to which it is coupled with. So addresses and tokens are indirectly coupled via ",(0,s.kt)("inlineCode",{parentName:"p"},"outputs"),".\nSo basically the sum of outputs and their amounts under the given address is a balance of the given address, ie. the number of tokens the given address can spend. And the sum of all unspent outputs and their amounts is equal to the total supply."),(0,s.kt)("p",null,"Before the chapter is wrapped up, one thing was left unexplained: ",(0,s.kt)("em",{parentName:"p"},'"how are outputs being sent and broadcasted to the network?"')," ",(0,s.kt)("inlineCode",{parentName:"p"},"Outputs")," are being sent encapsulated in a ",(0,s.kt)("inlineCode",{parentName:"p"},"message")," as part of the ",(0,s.kt)("inlineCode",{parentName:"p"},"SignedTransaction")," payload."),(0,s.kt)("h2",{id:"outputs"},"Outputs"),(0,s.kt)("p",null,"There are three functions to get ",(0,s.kt)("inlineCode",{parentName:"p"},"UTXO")," outputs (related to the given address):"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Client.getAddressOutputs(str)"),": it expects an address in Bech32 format and returns a ",(0,s.kt)("inlineCode",{parentName:"li"},"str[]")," of ",(0,s.kt)("inlineCode",{parentName:"li"},"output_ids")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Client.getOutput(str)"),": it expects an ",(0,s.kt)("inlineCode",{parentName:"li"},"output_id")," and returns the UTXO output metadata associated with it"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Client.findOutputs(output_ids (optional), addresses (optional))"),": it is a bit more general and it searches for ",(0,s.kt)("inlineCode",{parentName:"li"},"UTXO")," outputs associated with the given ",(0,s.kt)("inlineCode",{parentName:"li"},"output_ids")," and/or ",(0,s.kt)("inlineCode",{parentName:"li"},"addresses"))),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    const outputs = await client.getAddressOutputs('atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86');\n    console.log(outputs);\n}\n\nrun()\n"),(0,s.kt)("p",null,"Output example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},"[\n  '0f2d5d2651f8061a9f5417d0658009f32b2e3f77f9706b0be3b4b3f466171f360000',\n  '7614ba900a90b130707766a660a454942ac7cc4adea3fb9ad0cdca90114417c20000',\n  '768c20c15a290e02a43b83263a98501b9d7eb0b57da40a9247289c672de63ea60000'\n]\n")),(0,s.kt)("p",null,"Then the function ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.getOutput(str)")," can be used to get metadata about the given ",(0,s.kt)("inlineCode",{parentName:"p"},"output_id"),":"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    const output = await client.getOutput('a22cba0667c922cbb1f8bdcaf970b2a881ccd6e88e2fcce50374de2aac7c37720000');\n    console.log(output);\n}\n\nrun()\n"),(0,s.kt)("p",null,"Output example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "messageId": "f303bc90a5ed3ef15af5fc6aa81a739978c59458a71e68ce8e380f1f534da1e6",\n  "transactionId": "0f2d5d2651f8061a9f5417d0658009f32b2e3f77f9706b0be3b4b3f466171f36",\n  "outputIndex": 0,\n  "isSpent": false,\n  "address": "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r",\n  "amount": 1000000\n}\n')),(0,s.kt)("p",null,"A function ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.findOutputs()")," is a convenient shortcut combining both mentioned methods in a single call:"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    const outputs = await client.findOutputs(outputIds = [], addresses = [\"atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86\"]);\n    console.log(outputs);\n}\n\nrun()\n"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"it supports two arguments, a list of ",(0,s.kt)("inlineCode",{parentName:"li"},"output_ids")," or a list of ",(0,s.kt)("inlineCode",{parentName:"li"},"addresses"))),(0,s.kt)("p",null,"Output example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "messageId": "f303bc90a5ed3ef15af5fc6aa81a739978c59458a71e68ce8e380f1f534da1e6",\n    "transactionId": "0f2d5d2651f8061a9f5417d0658009f32b2e3f77f9706b0be3b4b3f466171f36",\n    "outputIndex": 0,\n    "isSpent": false,\n    "address": "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r",\n    "amount": 1000000\n  },\n  {\n    "messageId": "825266a79c0ffb6001ed263eb150357863b7d0052627c5766e8ef5acd6fed533",\n    "transactionId": "768c20c15a290e02a43b83263a98501b9d7eb0b57da40a9247289c672de63ea6",\n    "outputIndex": 0,\n    "isSpent": false,\n    "address": "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r",\n    "amount": 1000000\n  }\n]\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"message_id"),": refers to the encapsulating message in which the transaction was sent"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"transaction_id"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"output_index"),": refer to the given output within the ",(0,s.kt)("inlineCode",{parentName:"li"},"SignedTransaction")," payload. There may be several different ",(0,s.kt)("inlineCode",{parentName:"li"},"outputs")," involved in a single transaction so just ",(0,s.kt)("inlineCode",{parentName:"li"},"transaction_id")," is not enough"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"output"),": this section provides details about the iota address to which the given ",(0,s.kt)("inlineCode",{parentName:"li"},"unspent transaction output")," is coupled with"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"amount"),": states an amount of tokens related to the ",(0,s.kt)("inlineCode",{parentName:"li"},"output")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"is_spent"),": of course, is a very important one indicating whether the given ",(0,s.kt)("inlineCode",{parentName:"li"},"output")," is a part of the actual ledger state or not. As mentioned above, if an output was already spent, it is not part of the ledger state any more and was replaced by some other ",(0,s.kt)("inlineCode",{parentName:"li"},"output(s)")," in the process")),(0,s.kt)("p",null,"So this is quite an interesting part, notice that the ",(0,s.kt)("inlineCode",{parentName:"p"},"output_id")," that was used in a function call to get output details is the same as a combination of ",(0,s.kt)("inlineCode",{parentName:"p"},"transaction_id")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"output index"),"."),(0,s.kt)("p",null,"This way a transaction is tightly coupled with ",(0,s.kt)("inlineCode",{parentName:"p"},"outputs")," since the ",(0,s.kt)("inlineCode",{parentName:"p"},"SignedTransaction")," payload is a main vehicle how ",(0,s.kt)("inlineCode",{parentName:"p"},"outputs")," are being created and spent, and altogether everything is encapsulated in a ",(0,s.kt)("inlineCode",{parentName:"p"},"message"),"."),(0,s.kt)("h2",{id:"messages"},"Messages"),(0,s.kt)("p",null,"As mentioned above, the ",(0,s.kt)("inlineCode",{parentName:"p"},"message")," is encapsulating data structure that is being actually broadcasted across the network. It is an atomic unit that is accepted/rejected as a whole."),(0,s.kt)("p",null,"There is a function ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.postMessage(message)")," that accepts a message instance and sends it over a network. Alternatively, there is also a convenience ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageSender")," helper class with respective chaining calls that prepares a message instance and broadcasts it over the network."),(0,s.kt)("p",null,"The simplest message that can be broadcasted is a message without any particular payload:"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    const messageId = await client.message().submit();\n    console.log(messageId);\n}\n\nrun()\n"),(0,s.kt)("p",null,"Output example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-string"},"{\n  message: {\n    networkId: '14379272398717627559',\n    parentMessageIds: [\n      '03ddc83fad172a322fb00fb4e449436e9d1117ff390879100647c650a30c2d52',\n      '252798210fa9816f6fd40f1b19095da9f2dc88ae06fc4c0523a928a29d0d782e',\n      'a8e4f4cd49227068424ead8da187a48fdaa7ce8ffc4b9ac0ee2d5d3f2fcd7e70',\n      'dbbc8044bc624b3378e1dda83ab95f9be468b06a6a9806c76a70353182028cf9'\n    ],\n    payload: null,\n    nonce: '9223372036854784215'\n  },\n  messageId: '10dbee9cf3c58507725861b34ac711058dc13f709be1a6d21f1dc0af17b06379'\n}\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"message_id")," is a unique id that refers to the given message in the network")),(0,s.kt)("p",null,"Once a message is broadcasted, there is the ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageFinder")," helper class instantiated via ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.getMessage()")," function that provides helper functions related to the given message, such as ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.getMessage().data(str)")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.getMessage().metadata(str)"),":"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    // get message data by message id (get a random message id with getTips)\n    const tips = await client.getTips();\n    const message_data = await client.getMessage().data(tips[0]);\n    const message_metadata = await client.getMessage().metadata(tips[0]);\n    console.log(message_metadata);\n    console.log(message_data);\n\n    // get indexation data by index\n    const message_ids = await client.getMessage().index(\"IOTA.RS BINDING - NODE.JS\")\n    for (message_id of message_ids) {\n        const message_wrapper = await client.getMessage().data(message_id)\n        console.log(Buffer.from(message_wrapper.message.payload.data, 'hex').toString('utf8'));\n    }\n}\n\nrun()\n"),(0,s.kt)("p",null,"Output example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'Message meta data:\n{\n   "messageId":"e52b631bc7500366b90c6e11eb7fd6abaa7527f9bb5b4b512b0b9112bb9e7be8",\n   "parentMessageIds": [\n      "26d72339ed262c1ec29d6c91de6be26d067b3327191f5e47606df53cc40e334e",\n      "6289ea0aecf3830e5e8d9925959bb6e804e324bb6db23c5701f7a538d12831f6",\n      "fdbf2d02603235fdff99f0ceb57705ead95041d62de386387f2922e5d9f6c502",\n      "ffa26139ca7f9d4849e118ff369fb3a387c8fefd8d15232b8353d4acf334324c"\n   ],\n   "isSolid":true,\n   "shouldPromote":false,\n   "shouldReattach":false\n}\n\nMessage data:\n{\n   "message": {\n      "networkId":"14379272398717627559",\n      "parentMessageIds": [\n         "27782707e4cbf84ca26b3db881bbf39b6429f9ee736a0cbe5a1c177d7a52b05d",\n         "61cdf92c64a3304bbbabaf9fbfb0ea7ef9624e1eedea68efbe08595ccdf853e1",\n         "a222d13e3ee51b56b0b0e38140a5f7f813b6d9e29b752d7e1e2424099455080d",\n         "ab6bca20091b58dcbb0906438a7e47bfb11621c4a37b8d118b565f7f138a40d6"\n      ],\n      "payload": {\n         "type":2,\n         "index":"484f524e4554205370616d6d6572",\n         "data":"42696e61727920697320746865206675747572652e0a436f756e743a2031333936393530390a54696d657374616d703a20323032312d30352d33315431353a33363a30392b30323a30300a54697073656c656374696f6e3a203337c2b573"\n         },\n      "nonce":"246736"\n   },\n   "messageId":"30d87fa9917602e5685638e37802bde11b260bd2379f6c850704d7babd365b44"\n}\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Client.getMessage().metadata()")," provides information on how the given message fits to network structures such as ",(0,s.kt)("inlineCode",{parentName:"li"},"ledger_inclusion_state"),", etc."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"Client.getMessage().data()")," provides all data that relates to the given message and its payload(s)")),(0,s.kt)("h3",{id:"indexationpayload"},"IndexationPayload"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"IndexationPayload")," is a payload type that can be used to attach an arbitrary ",(0,s.kt)("inlineCode",{parentName:"p"},"data")," and key ",(0,s.kt)("inlineCode",{parentName:"p"},"index")," to a message. At least ",(0,s.kt)("inlineCode",{parentName:"p"},"index")," should be provided in order to send the given payload. Data part (as ",(0,s.kt)("inlineCode",{parentName:"p"},"bytes[]"),") is optional one:"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    const message = await client.message()\n        .index('IOTA.RS BINDING - NODE.JS')\n        .data('some utf based data')\n        .submit();\n\n    console.log(message);\n}\n\nrun()\n"),(0,s.kt)("p",null,"Output example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "message": {\n      "networkId":"14379272398717627559",\n      "parentMessageIds": [\n         "1a383abbe5f6a6b0899d718975c3119643aa784a68d04075f4e986fd7a0c0e4b",\n         "6098f889e31911833df7b7839e8b222d701ab496f7dfa1a719087edf4fa7ae52",\n         "a98b47db4e8254eccc738c968bd35b08a5491e56d6c1a18af298c42bbd8c3a46",\n         "da6796c0842c08de832c7948fffedc0d5adce372e50a108f26a128dba6096d31"\n      ],\n      "payload": {\n         "type":2,\n         "index":"494f54412e52532042494e44494e47202d204e4f44452e4a53",\n         "data":"736f6d65207574662062617365642064617461"\n      },\n      "nonce":"13835058055282176519"\n   },\n   "messageId":"10f59c101cec669b0a0ba163bc777184c7f63455f5e771d42f910a1ba2ad20ff"\n}\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Feel free to check the given message using its ",(0,s.kt)("inlineCode",{parentName:"li"},"message_id")," via ",(0,s.kt)("a",{parentName:"li",href:"https://explorer.iota.org/devnet/message/8d4fa37be3c00691131c2c3e03e7b8b956c9118a2ce4be3a8597d51d82ed2de9"},"Tangle explorer")),(0,s.kt)("li",{parentName:"ul"},"There are three payloads prepared (",(0,s.kt)("inlineCode",{parentName:"li"},"transaction"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"milestone")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"indexation"),") however only ",(0,s.kt)("inlineCode",{parentName:"li"},"indexation")," payload is leveraged this time"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"data")," contains an arbitrary data encoded in bytes"),(0,s.kt)("li",{parentName:"ul"},"Please note there is no IOTA address involved while sending data messages. Such messages are referenced using ",(0,s.kt)("inlineCode",{parentName:"li"},"message_id")," or key ",(0,s.kt)("inlineCode",{parentName:"li"},"index")),(0,s.kt)("li",{parentName:"ul"},"IOTA addresses are part of the ",(0,s.kt)("inlineCode",{parentName:"li"},"UTXO")," data structure that is sent using the ",(0,s.kt)("inlineCode",{parentName:"li"},"SignedTransaction")," payload explained below")),(0,s.kt)("h3",{id:"signedtransaction"},"SignedTransaction"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"SignedTransaction")," is a payload type that is used to transfer value-based messages as ",(0,s.kt)("inlineCode",{parentName:"p"},"UTXO")," (Unspent Transaction Output)."),(0,s.kt)("p",null,"As mentioned above, this core payload changes the ledger state as old ",(0,s.kt)("inlineCode",{parentName:"p"},"outputs")," are being spent (replaced) and new ",(0,s.kt)("inlineCode",{parentName:"p"},"outputs")," are being created:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"async function run(){\n    const { ClientBuilder } = require('@iota/client');\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    const message_data = await client.getMessage().data(\"92f427d68c7008a81fde290b9cb99071373d9893d65718bfc22928273877e041\");\n    console.log(message_data);\n}\n\nrun()\n")),(0,s.kt)("p",null,"Example of a message with a ",(0,s.kt)("inlineCode",{parentName:"p"},"SignedTransaction")," payload:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "message": {\n        "networkId": "14379272398717627559",\n        "parentMessageIds": [\n            "a59a5d11da0944c88b58f9f9c095c11ee4b8b7fd9da47bd25412d39f815bb804",\n            "c3d42c42eccd25bc3374a0552e3a4b21180facece14f31c36e5ac580e5496ccc",\n            "dae4a36cef9a3fd03caff5ddbc5c90bc5523477f4e4937837202bfe4bd5b98aa",\n            "fe188a4f57ecd6a135b05b31913d86617550d9397476ab5bb7445138f782ec34"\n        ],\n        "payload": {\n            "type": 0,\n            "essence": {\n                "type": 0,\n                "inputs": [\n                    {\n                        "type": 0,\n                        "transactionId": "b2b9723c9119f4fb49084472e72821e842ba4779df02e1038f03dd8b25d96730",\n                        "transactionOutputIndex": 1\n                    }\n                ],\n                "outputs": [\n                    {\n                        "type": 0,\n                        "address": {\n                            "type": 0,\n                            "address": "43e80947ebd17637569ba7f90fd2541f50038de731467c45aa5c92d4429c9446"\n                        },\n                        "amount": 1000\n                    },\n                    {\n                        "type": 0,\n                        "address": {\n                            "type": 0,\n                            "address": "b4d1e9abfbcf4d2d2f0e042f23301a7d23f6ac1bde0a1fed508de5afec884ba8"\n                        },\n                        "amount": 8995995\n                    }\n                ],\n                "payload": null\n            },\n            "unlockBlocks": [\n                {\n                    "type": 0,\n                    "signature": {\n                        "type": 0,\n                        "publicKey": "27177dd41cc479ed379b8ad2535d66fa58480c119a8a15a7a296f055401ab958",\n                        "signature": "8403dc1fb949365e960f14cdc19b6b3abb6b0a6bce83f1082a33e3857a30ddd2be1098074b6c261f442db8e59eb640002d24d9a577262fd8152c6fee2d076c0b"\n                    }\n                }\n            ]\n        },\n        "nonce": "156106"\n    },\n    "messageId": "92f427d68c7008a81fde290b9cb99071373d9893d65718bfc22928273877e041"\n}\n')),(0,s.kt)("p",null,"Each ",(0,s.kt)("inlineCode",{parentName:"p"},"transaction")," includes the following set of information:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"inputs"),": list of valid ",(0,s.kt)("inlineCode",{parentName:"li"},"outputs")," that should be used to fund the given message. Those ",(0,s.kt)("inlineCode",{parentName:"li"},"outputs")," will be spent and once the message is confirmed, those outputs are not valid anymore. Outputs are uniquely referenced via ",(0,s.kt)("inlineCode",{parentName:"li"},"transaction_id")," and inner ",(0,s.kt)("inlineCode",{parentName:"li"},"index"),". At least one output has to be given with enough balance to source all ",(0,s.kt)("inlineCode",{parentName:"li"},"outputs")," of the given message"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"outputs"),": list of IOTA address(es) and related amount(s) that the input ",(0,s.kt)("inlineCode",{parentName:"li"},"outputs")," should be split among. Based on this information, new ",(0,s.kt)("inlineCode",{parentName:"li"},"UTXO")," entities (outputs) are being created"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"unlock_blocks"),": it includes a transaction signature(s) (currently based on ",(0,s.kt)("inlineCode",{parentName:"li"},"Ed25519")," scheme) that proofs token ownership based on a valid seed. Needless to say, only the valid seed owner is able to correctly sign the given transaction and proof the ownership of tokens under the given output(s). Each input ",(0,s.kt)("inlineCode",{parentName:"li"},"output")," has to have a corresponding ",(0,s.kt)("inlineCode",{parentName:"li"},"unblockBlocks")," entry in case more ",(0,s.kt)("inlineCode",{parentName:"li"},"outputs")," are used to fund the operation either using the given signature or as a reference to the existing signature"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"payload"),": each ",(0,s.kt)("inlineCode",{parentName:"li"},"SignedTransaction"),"(payload type 0) can include additional payload(s) such as ",(0,s.kt)("inlineCode",{parentName:"li"},"IndexationPayload")," (payload type 1), etc. Meaning, any value-based messages can also contain arbitrary data and its key index. It is also an example how individual payloads can be encapsulated on different levels of concern")),(0,s.kt)("p",null,"Sending value-based messages is also a very straightforward process via the ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageSender")," helper class."),(0,s.kt)("p",null,"As a minimum, it needs a valid seed, output addresses, and amount. The method finds valid output(s) that can be used to fund the given amount(s) and the unspent amount is sent to the same address:"),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n    const {\n        ClientBuilder\n    } = require('@iota/client');\n\n    // Get the seed from environment variable\n    const IOTA_SEED_SECRET = process.env.IOTA_SEED_SECRET;\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    const message = await client.message()\n        .seed(IOTA_SEED_SECRET)\n        .output('atoi1qqydc70mpjdvl8l2wyseaseqwzhmedzzxrn4l9g2c8wdcsmhldz0ulwjxpz', 1000000)\n        .submit();\n\n    console.log(message);\n}\n\nrun()\n"),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"We recommend to use the official ",(0,s.kt)("inlineCode",{parentName:"p"},"wallet.rs")," library together with ",(0,s.kt)("inlineCode",{parentName:"p"},"stronghold.rs")," enclave for value-based transfers. This combination incorporates the best security practices while dealing with seeds, related addresses and ",(0,s.kt)("inlineCode",{parentName:"p"},"UTXO"),". See more information on ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/wallet.rs/welcome"},"Chrysalis docs"),"."))),(0,s.kt)("h4",{id:"dust-protection"},"Dust protection"),(0,s.kt)("p",null,"Please also note, there is a ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/faq#what-is-dust-protection-and-how-does-it-work"},"dust protection")," mechanism implemented in the network protocol to avoid malicious actors to spam network in order to decrease node performance while keeping track of unspent amount (",(0,s.kt)("inlineCode",{parentName:"p"},"UTXO"),"):"),(0,s.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},'"... microtransaction below 1Mi of IOTA tokens ',"[can be sent]",' to another address if there is already at least 1Mi on that address"\nThat\'s why we sent 1Mi in the given example to comply with the protection."'))),(0,s.kt)("h2",{id:"listening-to-mqtt"},"Listening to MQTT"),(0,s.kt)("p",null,"IOTA node(s) provides a ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/MQTT"},"Message Queuing Telemetry Transport")," (MQTT) layer, if enabled, which is a lightweight publish-subscribe network protocol that provides information about events that is being triggered by the IOTA network."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"iota.rs")," client library supports asynchronous event listeners that can be listened to, and continuously receive MQTT events based on a ",(0,s.kt)("inlineCode",{parentName:"p"},"topic"),", which can be:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"milestones/latest"),(0,s.kt)("li",{parentName:"ul"},"milestones/confirmed"),(0,s.kt)("li",{parentName:"ul"},"messages"),(0,s.kt)("li",{parentName:"ul"},"messages/referenced"),(0,s.kt)("li",{parentName:"ul"},"messages/indexation/{index}"),(0,s.kt)("li",{parentName:"ul"},"messages/{messageId}/metadata"),(0,s.kt)("li",{parentName:"ul"},"transactions/{transactionId}/included-message"),(0,s.kt)("li",{parentName:"ul"},"outputs/{outputId}"),(0,s.kt)("li",{parentName:"ul"},"addresses/{address}/outputs"),(0,s.kt)("li",{parentName:"ul"},"addresses/ed25519/{address}/outputs")),(0,s.kt)("p",null,"The listener is reachable via an instance of a ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.TopicSubscriber")," object that is returned from the ",(0,s.kt)("inlineCode",{parentName:"p"},"Client.subscriber()")," function."),(0,s.kt)("p",null,"It offers several chaining calls:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},".topic(str)")," / ",(0,s.kt)("inlineCode",{parentName:"li"},".topics(str[])"),": a topic or list of topics that should trigger a provided callback"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},".subscribe(cb)"),": it subscribes the listener to a callback function that is being triggered every time the given topic(s) is noticed"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},".unsubscribe(cb)"),": it unsubscribes the listener from the given topics. Once unsubscribed, then the given callback function is executed in a form ",(0,s.kt)("inlineCode",{parentName:"li"},"(err, message) => {}"))),(0,s.kt)(o.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n    const {\n        ClientBuilder\n    } = require('@iota/client');\n\n    // client connects to a node that has MQTT enabled\n    const client = new ClientBuilder()\n        .node('https://api.thin-hornet-1.h.chrysalis-devnet.iota.cafe')\n        .build();\n\n    client.subscriber().topics(['milestones/confirmed', 'messages']).subscribe((err, data) => {\n        console.log(data);\n        // To get the message id from messages `client.getMessageId(data.payload)` can be used\n    })\n\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    // unsubscribe from 'messages' topic, will continue to receive events for 'milestones/confirmed'\n    client.subscriber().topics(['messages']).unsubscribe((err, data) => {\n        console.log(data);\n    })\n}\n\nrun()\n"),(0,s.kt)("p",null,"Please note: The IOTA node needs to have the MQTT layer enabled. There is a set of test nodes available that have MQTT enabled. See ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/devnet/"},"devnet chapter")," for more information."))}h.isMDXComponent=!0},93965:function(e,t,n){t.Z=n.p+"assets/images/address_generation-3a86c22395de7ffee579dd158bceccd9.svg"},69942:function(e,t,n){t.Z=n.p+"assets/images/messages_in_tangle-903d698770022c248102efa09bdb27d8.svg"},80441:function(e,t,n){t.Z=n.p+"assets/images/utxo-463592a9e83300c70fb7ae4a0285fd85.svg"}}]);