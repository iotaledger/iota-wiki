"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[83593],{27701:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return u},default:function(){return _},frontMatter:function(){return c},metadata:function(){return h},toc:function(){return p}});var i=t(83117),o=t(80102),a=(t(67294),t(3905)),r=t(76018),s=t(71871),d=t(55990),l=["components"],c={title:"Resolve a DID history",sidebar_label:"Resolve a DID history",description:"Resolve a DID history using the IOTA Identity Rust Library or its WASM binding",image:"/img/Identity_icon.png",keywords:["Rust","WASM"]},u=void 0,h={unversionedId:"decentralized_identifiers/resolve_history",id:"decentralized_identifiers/resolve_history",title:"Resolve a DID history",description:"Resolve a DID history using the IOTA Identity Rust Library or its WASM binding",source:"@site/external/identity.rs/documentation/docs/decentralized_identifiers/resolve_history.mdx",sourceDirName:"decentralized_identifiers",slug:"/decentralized_identifiers/resolve_history",permalink:"/identity.rs/decentralized_identifiers/resolve_history",editUrl:"https://github.com/iotaledger/identity.rs/edit/support/v0.5/external/identity.rs/documentation/docs/decentralized_identifiers/resolve_history.mdx",tags:[],version:"current",frontMatter:{title:"Resolve a DID history",sidebar_label:"Resolve a DID history",description:"Resolve a DID history using the IOTA Identity Rust Library or its WASM binding",image:"/img/Identity_icon.png",keywords:["Rust","WASM"]},sidebar:"docs",previous:{title:"Resolve",permalink:"/identity.rs/decentralized_identifiers/resolve"},next:{title:"Create a Private Tangle",permalink:"/identity.rs/decentralized_identifiers/private_tangle"}},m={},p=[{value:"Example",id:"example",level:2}],y={toc:p};function _(e){var n=e.components,t=(0,o.Z)(e,l);return(0,a.kt)("wrapper",(0,i.Z)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"Below is an example that performs multiple integration chain updates, and demonstrates how to resolve the DID Document history to view these chains."),(0,a.kt)(r.Z,{groupId:"programming-languages",defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Node.js",value:"nodejs"}],mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"rust",mdxType:"TabItem"},(0,a.kt)(d.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2020-2022 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! Advanced example that performs multiple updates and demonstrates how to resolve the\n//! DID Document history to view them.\n//!\n//! cargo run --example did_history\n\nuse identity::core::json;\nuse identity::core::FromJson;\nuse identity::core::Timestamp;\nuse identity::crypto::KeyPair;\nuse identity::did::MethodScope;\nuse identity::did::Service;\nuse identity::did::DID;\nuse identity::iota::Client;\nuse identity::iota::DocumentHistory;\nuse identity::iota::Receipt;\nuse identity::iota::Result;\nuse identity::iota_core::IotaDocument;\nuse identity::iota_core::IotaService;\nuse identity::iota_core::IotaVerificationMethod;\nuse identity::prelude::*;\n\nmod create_did;\n\n#[rustfmt::skip]\n#[tokio::main]\nasync fn main() -> Result<()> {\n  // Create a client instance to send messages to the Tangle.\n  let client: Client = Client::new().await?;\n\n  // ===========================================================================\n  // DID Creation\n  // ===========================================================================\n\n  // Create a signed DID Document and KeyPair (see "create_did.rs" example).\n  let (document, keypair, original_receipt): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // ===========================================================================\n  // Integration Chain Spam\n  // ===========================================================================\n\n  // Publish several spam messages to the same index as the integration chain on the Tangle.\n  // These are not valid DID messages and are simply to demonstrate that invalid messages\n  // can be included in the history for debugging invalid DID documents.\n  let int_index: &str = document.integration_index();\n  client.publish_json(int_index, &json!({ "intSpam:1": true })).await?;\n  client.publish_json(int_index, &json!({ "intSpam:2": true })).await?;\n  client.publish_json(int_index, &json!({ "intSpam:3": true })).await?;\n  client.publish_json(int_index, &json!({ "intSpam:4": true })).await?;\n  client.publish_json(int_index, &json!({ "intSpam:5": true })).await?;\n\n  // ===========================================================================\n  // Integration Chain Update 1\n  // ===========================================================================\n\n  // Prepare an integration chain update, which writes the full updated DID document to the Tangle.\n  let int_doc_1 = {\n    let mut int_doc_1 = document.clone();\n\n    // Add a new Service with the tag "linked-domain-1".\n    let service: IotaService = Service::from_json_value(json!({\n      "id": int_doc_1.id().to_url().join("#linked-domain-1")?,\n      "type": "LinkedDomains",\n      "serviceEndpoint": "https://iota.org/"\n    }))?;\n    assert!(int_doc_1.insert_service(service));\n\n    // Add a second Service with the tag "linked-domain-2".\n    let service: IotaService = Service::from_json_value(json!({\n      "id": int_doc_1.id().to_url().join("#linked-domain-2")?,\n      "type": "LinkedDomains",\n      "serviceEndpoint": {\n        "origins": ["https://iota.org/", "https://example.com/"]\n      }\n    }))?;\n    assert!(int_doc_1.insert_service(service));\n\n    // Add a new VerificationMethod with a new KeyPair, with the tag "keys-1"\n    let keys_1: KeyPair = KeyPair::new(KeyType::Ed25519)?;\n    let method_1: IotaVerificationMethod = IotaVerificationMethod::new(int_doc_1.id().clone(), keys_1.type_(), keys_1.public(), "keys-1")?;\n    assert!(int_doc_1.insert_method(method_1, MethodScope::VerificationMethod).is_ok());\n\n    // Add the `message_id` of the previous message in the chain.\n    // This is REQUIRED in order for the messages to form a chain.\n    // Skipping / forgetting this will render the publication useless.\n    int_doc_1.metadata.previous_message_id = *original_receipt.message_id();\n    int_doc_1.metadata.updated = Some(Timestamp::now_utc());\n\n    // Sign the DID Document with the original private key.\n    int_doc_1.sign_self(keypair.private(), int_doc_1.default_signing_method()?.id().clone())?;\n\n    int_doc_1\n  };\n\n  // Publish the updated DID Document to the Tangle, updating the integration chain.\n  // This may take a few seconds to complete proof-of-work.\n  let int_receipt_1: Receipt = client.publish_document(&int_doc_1).await?;\n\n  // ===========================================================================\n  // DID History 1\n  // ===========================================================================\n\n  // Retrieve the message history of the DID.\n  let history_1: DocumentHistory = client.resolve_history(document.id()).await?;\n\n  // The history shows two documents in the integration chain.\n  println!("History (1) = {:#?}", history_1);\n\n  // ===========================================================================\n  // Integration Chain Update 2\n  // ===========================================================================\n\n  // Publish a second integration chain update\n  let int_doc_2 = {\n    let mut int_doc_2 = int_doc_1.clone();\n\n    // Remove the #keys-1 VerificationMethod\n    int_doc_2.remove_method(&int_doc_2.id().to_url().join("#keys-1")?)?;\n\n    // Remove the #linked-domain-1 Service\n    int_doc_2.remove_service(&int_doc_2.id().to_url().join("#linked-domain-1")?)?;\n\n    // Add a VerificationMethod with a new KeyPair, called "keys-2"\n    let keys_2: KeyPair = KeyPair::new(KeyType::Ed25519)?;\n    let method_2: IotaVerificationMethod = IotaVerificationMethod::new(int_doc_2.id().clone(), keys_2.type_(), keys_2.public(), "keys-2")?;\n    assert!(int_doc_2.insert_method(method_2, MethodScope::VerificationMethod).is_ok());\n\n    // Note: the `previous_message_id` points to the `message_id` of the last integration chain\n    //       update.\n    int_doc_2.metadata.previous_message_id = *int_receipt_1.message_id();\n    int_doc_2.metadata.updated = Some(Timestamp::now_utc());\n\n    int_doc_2.sign_self(keypair.private(), int_doc_2.default_signing_method()?.id().clone())?;\n    int_doc_2\n  };\n  let _int_receipt_2: Receipt = client.publish_document(&int_doc_2).await?;\n\n  // ===========================================================================\n  // DID History 2\n  // ===========================================================================\n\n  // Retrieve the updated message history of the DID.\n  let history_2: DocumentHistory = client.resolve_history(document.id()).await?;\n\n  // The history now shows three documents in the integration chain.\n  println!("History (2) = {:#?}", history_2);\n\n  Ok(())\n}\n')),(0,a.kt)(s.Z,{value:"nodejs",mdxType:"TabItem"},(0,a.kt)(d.Z,{className:"language-javascript",mdxType:"CodeBlock"},'// Copyright 2020-2022 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n    Client,\n    Document,\n    KeyPair,\n    KeyType,\n    MethodScope,\n    Service,\n    Timestamp,\n    VerificationMethod\n} from \'@iota/identity-wasm\';\nimport {createIdentity} from "./create_did";\n\n/**\n Advanced example that performs multiple updates and demonstrates how to resolve the DID Document history to view them.\n\n @param {{network: Network, explorer: ExplorerUrl}} clientConfig\n **/\nasync function resolveHistory(clientConfig) {\n    // Create a client instance to publish messages to the configured Tangle network.\n    const client = await Client.fromConfig({\n        network: clientConfig.network\n    });\n\n    // ===========================================================================\n    // DID Creation\n    // ===========================================================================\n\n    // Create a new identity (see "create_did.js" example).\n    const {doc, key, receipt: originalReceipt} = await createIdentity(clientConfig);\n\n    // ===========================================================================\n    // Integration Chain Spam\n    // ===========================================================================\n\n    // Publish several spam messages to the same index as the integration chain on the Tangle.\n    // These are not valid DID documents and are simply to demonstrate that invalid messages can be\n    // included in the history, potentially for debugging invalid DID documents.\n    const intIndex = doc.integrationIndex();\n    await client.publishJSON(intIndex, {"intSpam:1": true});\n    await client.publishJSON(intIndex, {"intSpam:2": true});\n    await client.publishJSON(intIndex, {"intSpam:3": true});\n    await client.publishJSON(intIndex, {"intSpam:4": true});\n    await client.publishJSON(intIndex, {"intSpam:5": true});\n\n    // ===========================================================================\n    // Integration Chain Update 1\n    // ===========================================================================\n\n    // Prepare an integration chain update, which writes the full updated DID document to the Tangle.\n    const intDoc1 = doc.clone();\n\n    // Add a new Service with the tag "linked-domain-1"\n    const service1 = new Service({\n        id: intDoc1.id().toUrl().join("#linked-domain-1"),\n        type: "LinkedDomains",\n        serviceEndpoint: "https://iota.org",\n    });\n    intDoc1.insertService(service1);\n\n    // Add a second Service with the tag "linked-domain-2"\n    const service2 = new Service({\n        id: intDoc1.id().toUrl().join("#linked-domain-2"),\n        type: "LinkedDomains",\n        serviceEndpoint: {\n            "origins": ["https://iota.org/", "https://example.com/"]\n        },\n    });\n    intDoc1.insertService(service2);\n\n    // Add a new VerificationMethod with a new KeyPair, with the tag "keys-1"\n    const keys1 = new KeyPair(KeyType.Ed25519);\n    const method1 = new VerificationMethod(intDoc1.id(), keys1.type(), keys1.public(), "keys-1");\n    intDoc1.insertMethod(method1, MethodScope.VerificationMethod());\n\n    // Add the `messageId` of the previous message in the chain.\n    // This is REQUIRED in order for the messages to form a chain.\n    // Skipping / forgetting this will render the publication useless.\n    intDoc1.setMetadataPreviousMessageId(originalReceipt.messageId());\n    intDoc1.setMetadataUpdated(Timestamp.nowUTC());\n\n    // Sign the DID Document with the original private key.\n    intDoc1.signSelf(key, intDoc1.defaultSigningMethod().id());\n\n    // Publish the updated DID Document to the Tangle, updating the integration chain.\n    // This may take a few seconds to complete proof-of-work.\n    const intReceipt1 = await client.publishDocument(intDoc1);\n\n    // Log the results.\n    console.log(`Int. Chain Update (1): ${clientConfig.explorer.messageUrl(intReceipt1.messageId())}`);\n\n    // ===========================================================================\n    // DID History 1\n    // ===========================================================================\n\n    // Retrieve the message history of the DID.\n    const history1 = await client.resolveHistory(doc.id());\n\n    // The history shows two documents in the integration chain.\n    console.log(`History (1): ${JSON.stringify(history1, null, 2)}`);\n\n    // ===========================================================================\n    // Integration Chain Update 2\n    // ===========================================================================\n\n    // Publish a second integration chain update\n    let intDoc2 = Document.fromJSON(intDoc1.toJSON());\n\n    // Remove the #keys-1 VerificationMethod\n    intDoc2.removeMethod(intDoc2.id().toUrl().join("#keys-1"));\n\n    // Remove the #linked-domain-1 Service\n    intDoc2.removeService(intDoc2.id().toUrl().join("#linked-domain-1"));\n\n    // Add a VerificationMethod with a new KeyPair, called "keys-2"\n    const keys2 = new KeyPair(KeyType.Ed25519);\n    const method2 = new VerificationMethod(intDoc2.id(), keys2.type(), keys2.public(), "keys-2");\n    intDoc2.insertMethod(method2, MethodScope.VerificationMethod());\n\n    // Note: the `previous_message_id` points to the `message_id` of the last integration chain\n    //       update.\n    intDoc2.setMetadataPreviousMessageId(intReceipt1.messageId());\n    intDoc2.setMetadataUpdated(Timestamp.nowUTC());\n    intDoc2.signSelf(key, intDoc2.defaultSigningMethod().id());\n    const intReceipt2 = await client.publishDocument(intDoc2);\n\n    // Log the results.\n    console.log(`Int. Chain Update (2): ${clientConfig.explorer.messageUrl(intReceipt2.messageId())}`);\n\n    // ===========================================================================\n    // DID History 2\n    // ===========================================================================\n\n    // Retrieve the updated message history of the DID.\n    const history2 = await client.resolveHistory(doc.id());\n\n    // The history now shows three documents in the integration chain.\n    console.log(`History (2): ${JSON.stringify(history2, null, 2)}`);\n}\n\nexport {resolveHistory};\n'))))}_.isMDXComponent=!0},71871:function(e,n,t){t.d(n,{Z:function(){return o}});var i=t(67294);function o(e){var n=e.children,t=e.hidden,o=e.className;return i.createElement("div",{role:"tabpanel",hidden:t,className:o},n)}},76018:function(e,n,t){t.d(n,{Z:function(){return c}});var i=t(83117),o=t(67294),a=t(5730),r=t(37559),s=t(86010),d="tabItem_LplD";function l(e){var n,t,a,l=e.lazy,c=e.block,u=e.defaultValue,h=e.values,m=e.groupId,p=e.className,y=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),_=null!=h?h:y.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),g=(0,r.lx)(_,(function(e,n){return e.value===n.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===u?u:null!=(n=null!=u?u:null==(t=y.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(a=y[0])?void 0:a.props.value;if(null!==v&&!_.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+_.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var f=(0,r.UB)(),D=f.tabGroupChoices,w=f.setTabGroupChoices,k=(0,o.useState)(v),I=k[0],b=k[1],S=[],T=(0,r.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var x=D[m];null!=x&&x!==I&&_.some((function(e){return e.value===x}))&&b(x)}var M=function(e){var n=e.currentTarget,t=S.indexOf(n),i=_[t].value;i!==I&&(T(n),b(i),null!=m&&w(m,i))},R=function(e){var n,t=null;switch(e.key){case"ArrowRight":var i=S.indexOf(e.currentTarget)+1;t=S[i]||S[0];break;case"ArrowLeft":var o=S.indexOf(e.currentTarget)-1;t=S[o]||S[S.length-1]}null==(n=t)||n.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":c},p)},_.map((function(e){var n=e.value,t=e.label,a=e.attributes;return o.createElement("li",(0,i.Z)({role:"tab",tabIndex:I===n?0:-1,"aria-selected":I===n,key:n,ref:function(e){return S.push(e)},onKeyDown:R,onFocus:M,onClick:M},a,{className:(0,s.Z)("tabs__item",d,null==a?void 0:a.className,{"tabs__item--active":I===n})}),null!=t?t:n)}))),l?(0,o.cloneElement)(y.filter((function(e){return e.props.value===I}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},y.map((function(e,n){return(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==I})}))))}function c(e){var n=(0,a.Z)();return o.createElement(l,(0,i.Z)({key:String(n)},e))}}}]);