"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[37756],{60167:function(t,e,r){r.r(e),r.d(e,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return u},toc:function(){return l},default:function(){return m}});var n=r(74034),s=r(79973),o=(r(67294),r(3905)),a=["components"],i={id:"smart-contracts-consensus",title:"Consensus",description:"In this article you will learn how the IOTA Smart Contract Consensus works.",keywords:["Cosensus","Smart Contracts","wasp","ISCP"]},c=void 0,u={unversionedId:"future/smart-contracts/smart-contracts-consensus",id:"future/smart-contracts/smart-contracts-consensus",isDocsHomePage:!1,title:"Consensus",description:"In this article you will learn how the IOTA Smart Contract Consensus works.",source:"@site/internal/learn/future/smart-contracts/06_consensus.md",sourceDirName:"future/smart-contracts",slug:"/future/smart-contracts/smart-contracts-consensus",permalink:"/learn/future/smart-contracts/smart-contracts-consensus",editUrl:"https://github.com/iota-community/iota-wiki/edit/main/internal/learn/future/smart-contracts/06_consensus.md",tags:[],version:"current",lastUpdatedAt:1635441480,formattedLastUpdatedAt:"10/28/2021",sidebarPosition:6,frontMatter:{id:"smart-contracts-consensus",title:"Consensus",description:"In this article you will learn how the IOTA Smart Contract Consensus works.",keywords:["Cosensus","Smart Contracts","wasp","ISCP"]},sidebar:"learn",previous:{title:"Decentralized Applications",permalink:"/learn/future/smart-contracts/smart-contracts-dapps"},next:{title:"Smart Contract Community Tutorials",permalink:"/learn/future/smart-contracts/smart-contracts-community-tutorials"}},l=[{value:"Distributed Processor",id:"distributed-processor",children:[],level:2},{value:"BLS Threshold Signatures",id:"bls-threshold-signatures",children:[],level:2}],h={toc:l};function m(t){var e=t.components,r=(0,s.Z)(t,a);return(0,o.kt)("wrapper",(0,n.Z)({},h,r,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this article, you will learn how the IOTA Smart Contract Consensus works."),(0,o.kt)("p",null,"IOTA Smart Contracts is a sharded smart contract network, where each smart contract chain is limited by its own scalability and is not hindered by the rest of the network."),(0,o.kt)("p",null,"The committee is of fixed size, thus we use a Byzantine Fault Tolerant (BFT) Algorithm, which guarantees consistency and byzantine fault tolerance if less than \u2153 of nodes are malicious. So the verification process runs on Nodes within a chain committee."),(0,o.kt)("h2",{id:"distributed-processor"},"Distributed Processor"),(0,o.kt)("p",null,"Verification means re-running the program yourself whenever you need to determine if you trust the state of the smart contract. Instead, to make the state transition trustworthy, the processor which runs the SC Program needs to be trustworthy."),(0,o.kt)("p",null,"This is the reason smart contracts are run by a distributed processor. The term \u201cdistributed processor\u201d refers to many processors performing the same calculations and coming to a consensus on the result of these computations. This consensus is reflected in the next block which updates the state of the chain."),(0,o.kt)("p",null,"In the case of Ethereum, the whole network is that distributed processor.\nIOTA Smart Contracts use a quorum majority voting in the ",(0,o.kt)("inlineCode",{parentName:"p"},"BFT")," setting to determine the consensus arrived at by the committee of different processors."),(0,o.kt)("p",null,"It should only be possible to produce valid signatures of inputs of\nthe anchor transaction by reaching the quorum in the committee of nodes. In this case, a confirmed anchor transaction\nbecomes a cryptographical proof of consensus in the committee."),(0,o.kt)("h2",{id:"bls-threshold-signatures"},"BLS Threshold Signatures"),(0,o.kt)("p",null,"IOTA Smart Contracts use BLS cryptography and threshold signatures in combination with\npolynomial (Shamir) secret sharing to achieve the requirement above.\nIn short, IOTA Smart Contracts use BLS addresses as state addresses (controlling addresses) of the chain account\nwhere the state of the chain is locked. The secret sharing and threshold signatures allow for\ncontrol of the address by any T out of N secret keys (partial private keys), where N is the size of\nthe committee and T is a quorum factor."),(0,o.kt)("p",null,"The \u201ccontrol of the address\u201d means the ability to produce a valid signature of the transaction to\nthe corresponding address. In threshold signatures the valid (master) signature can be\nreconstructed from any T out of N partial signatures. There is no need for all N of them and\nthere is no need to know the master private key in order to reconstruct a valid signature. Each\npartial signature is a signature by one out of N of secret keys, while each of those secret keys is\nknown only to the corresponding committee node."),(0,o.kt)("p",null,"IOTA Smart Contracts use the Dedis Kyber library in the implementation of Wasp. Goshimmer has BLS addresses implemented at its core. This means that BLS addresses are conventional addresses and BLS\nsignatures in transactions can be validated by the IOTA node just like any other type of\nsignature."),(0,o.kt)("hr",null),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Learn more about consensus in the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/iotaledger/wasp/raw/master/documentation/ISCP%20architecture%20description%20v3.pdf"},"IOTA Smart Contracts\nArchitecture description")),(0,o.kt)("li",{parentName:"ul"},"Participate and set up a ",(0,o.kt)("a",{parentName:"li",href:"/wasp/misc/docker"},"Wasp Node with Docker"),"."),(0,o.kt)("li",{parentName:"ul"},"Build a decentralized application with the ",(0,o.kt)("a",{parentName:"li",href:"/wasp/guide/schema/schema"},"Schema Tool"),".")))}m.isMDXComponent=!0},3905:function(t,e,r){r.d(e,{Zo:function(){return l},kt:function(){return d}});var n=r(67294);function s(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function o(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function a(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?o(Object(r),!0).forEach((function(e){s(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function i(t,e){if(null==t)return{};var r,n,s=function(t,e){if(null==t)return{};var r,n,s={},o=Object.keys(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||(s[r]=t[r]);return s}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(n=0;n<o.length;n++)r=o[n],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(s[r]=t[r])}return s}var c=n.createContext({}),u=function(t){var e=n.useContext(c),r=e;return t&&(r="function"==typeof t?t(e):a(a({},e),t)),r},l=function(t){var e=u(t.components);return n.createElement(c.Provider,{value:e},t.children)},h={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(t,e){var r=t.components,s=t.mdxType,o=t.originalType,c=t.parentName,l=i(t,["components","mdxType","originalType","parentName"]),m=u(r),d=s,p=m["".concat(c,".").concat(d)]||m[d]||h[d]||o;return r?n.createElement(p,a(a({ref:e},l),{},{components:r})):n.createElement(p,a({ref:e},l))}));function d(t,e){var r=arguments,s=e&&e.mdxType;if("string"==typeof t||s){var o=r.length,a=new Array(o);a[0]=m;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i.mdxType="string"==typeof t?t:s,a[1]=i;for(var u=2;u<o;u++)a[u]=r[u];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"}}]);