"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[192],{35274:function(e,r,t){t.r(r),t.d(r,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return u},toc:function(){return k},default:function(){return m}});var n=t(22122),a=t(19756),i=(t(67294),t(3905)),s=["components"],l={},o="Markers",u={unversionedId:"protocol_specification/markers",id:"protocol_specification/markers",isDocsHomePage:!1,title:"Markers",description:"Summary",source:"@site/external/goshimmer/documentation/docs/protocol_specification/markers.md",sourceDirName:"protocol_specification",slug:"/protocol_specification/markers",permalink:"/goshimmer/protocol_specification/markers",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"UTXO Output Types",permalink:"/goshimmer/protocol_specification/advanced_outputs"},next:{title:"Glossary",permalink:"/goshimmer/protocol_specification/glossary"}},k=[{value:"Summary",id:"summary",children:[]},{value:"Motivation",id:"motivation",children:[]},{value:"Dependency",id:"dependency",children:[]},{value:"Definitions",id:"definitions",children:[]},{value:"Design",id:"design",children:[{value:"The Markers",id:"the-markers",children:[]},{value:"Markers in Messages",id:"markers-in-messages",children:[]},{value:"The Sequence",id:"the-sequence",children:[]}]},{value:"Example 1",id:"example-1",children:[]},{value:"Example 2: Test for the Mapping interaction with the Booker",id:"example-2-test-for-the-mapping-interaction-with-the-booker",children:[]},{value:"Implementation details",id:"implementation-details",children:[{value:"Normalization of the referenced PMs and Sequences",id:"normalization-of-the-referenced-pms-and-sequences",children:[]},{value:"Markers Application: Past Cone Check",id:"markers-application-past-cone-check",children:[]},{value:"Markers Application: Approval Weight Estimation",id:"markers-application-approval-weight-estimation",children:[]}]}],c={toc:k};function m(e){var r=e.components,l=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,n.Z)({},c,l,{components:r,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"markers"},"Markers"),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"In order to know whether a message in the Tangle is orphaned or not, we introduce ",(0,i.kt)("strong",{parentName:"p"},"grades of finality")," to interpret the status of a message. The higher grade of finality is determined by the ",(0,i.kt)("strong",{parentName:"p"},"approval weight"),", which is the proportion of active consensus mana approving a given message."),(0,i.kt)("p",null,"To compute the approval weight of a given message we need to traverse the Tangle from the message to the tips and sum up the active consensus mana of all the messages in its future cone. The ",(0,i.kt)("strong",{parentName:"p"},"marker")," tool is a tool to efficiently estimate the approval weight of a message and that reduces the portion of the Tangle that needs to be traversed, and which finally results in the grade of finality."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": ",(0,i.kt)("em",{parentName:"p"},"Markers")," is not a core module of the Coordicide project."),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Markers")," is a tool to infer knowledge about the structure of the Tangle in terms of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"past/future cone membership;"),(0,i.kt)("li",{parentName:"ul"},"approximate approval weight of any message;"),(0,i.kt)("li",{parentName:"ul"},"tagging sections of the Tangle (e.g., branches) without having to traverse each message individually.")),(0,i.kt)("h2",{id:"dependency"},"Dependency"),(0,i.kt)("p",null,"Active Consensus Mana"),(0,i.kt)("h2",{id:"definitions"},"Definitions"),(0,i.kt)("p",null,"Let's define the terms related to markers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Sequence:")," A Sequence is a sequence of markers. Each Sequence corresponds to a UTXO branch, which help us to track the structure independently. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Sequence Identifier (",(0,i.kt)("inlineCode",{parentName:"strong"},"SID"),"):")," A Sequence Identifier is the unique identifier of a Sequence."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Marker Index (",(0,i.kt)("inlineCode",{parentName:"strong"},"MI"),"):")," A Marker Index is the marker rank in the marker DAG. Throughout the code the marker rank will be called index. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"marker:")," A marker is a pair of numbers: ",(0,i.kt)("inlineCode",{parentName:"li"},"SID")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"MI")," associated to a given message. Markers carrying the same ",(0,i.kt)("inlineCode",{parentName:"li"},"SID")," belong to the same Sequence."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"future marker (",(0,i.kt)("inlineCode",{parentName:"strong"},"FM"),"):")," A future marker of a message is the first marker in its future cone from different sequences; this field in the message metadata is updated when the new marker is generated in the future, following the rules defined in ",(0,i.kt)("a",{parentName:"li",href:"#future-markers"},"Future Markers"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"past marker (",(0,i.kt)("inlineCode",{parentName:"strong"},"PM"),"):")," A past marker of a message is a marker in its past cone. For a given sequence it is set to the newest past marker of its parents, that is the one that has the largest ",(0,i.kt)("inlineCode",{parentName:"li"},"MI"),". The past marker of a marker is set to itself."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"sequence rank:")," The rank of a sequence will be simply called rank throughout this code. Bear in mind that for clarity the marker rank is called index.")),(0,i.kt)("h2",{id:"design"},"Design"),(0,i.kt)("h3",{id:"the-markers"},"The Markers"),(0,i.kt)("p",null,"Markers are messages selected from the tip set periodically and assigned unique identifiers, in the form of $","[SID, MI]","$. "),(0,i.kt)("h4",{id:"marker-structure"},"Marker Structure"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SequenceID"),(0,i.kt)("td",{parentName:"tr",align:null},"uint64"),(0,i.kt)("td",{parentName:"tr",align:null},"The Sequence identifier of the marker.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Index"),(0,i.kt)("td",{parentName:"tr",align:null},"uint64"),(0,i.kt)("td",{parentName:"tr",align:null},"The index of the marker in the sequence.")))),(0,i.kt)("h4",{id:"create-markers"},"Create Markers"),(0,i.kt)("p",null,"A new marker is created when:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"the default conditions are met, which will be one of these options:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"every x messsages"),";")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"every t seconds"),";"),(0,i.kt)("li",{parentName:"ul"},"a mix of the first two!",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Upperbound given by the messages"),(0,i.kt)("li",{parentName:"ul"},"Lower temporal bound given by the time"))),(0,i.kt)("li",{parentName:"ul"},"every x messages that reference (directly or indirectly) the previous marker",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Lower bound given by rank (e.g., how far you are in terms of steps) -> >= 10 or something"),(0,i.kt)("li",{parentName:"ul"},"Upper bound given by the amount of messages referencing the previous one -> ~ 200 msgs"))))),(0,i.kt)("li",{parentName:"ol"},"A new sequence is created. ",(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"\ud83d\udce3 to be confirmed here.")))),(0,i.kt)("p",null,"A new marker is selected from the strong tips set randomly, and selected from the weak tips set if there's no strong tip. A new pair of $","[SID, MI]","$ is assigned to the new marker. "),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\ud83d\udce3  to be confirmed here.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"SID")," is set according to the following rules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Inherit the ",(0,i.kt)("inlineCode",{parentName:"li"},"SID")," from parents if the new marker references the latest marker of a sequence and meets the requirement to set up a new marker without initiating a new MS."),(0,i.kt)("li",{parentName:"ul"},"Create a new ",(0,i.kt)("inlineCode",{parentName:"li"},"SID")," if it is the first marker of a new sequence.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"MI")," is set to $MI = 1+ max(referencedMI)$, which complies to the rule:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Marker indexes (",(0,i.kt)("inlineCode",{parentName:"li"},"MI"),"s) are monotonically increasing such that $\\forall x \\in fc(y)$ => $MI_x > MI_y$, where $fc(y)$ is the future cone of $y$ and $x$ is any message in that future cone.")),(0,i.kt)("h3",{id:"markers-in-messages"},"Markers in Messages"),(0,i.kt)("p",null,"Each message keeps its associated marker information in two lists:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"past markers "),(0,i.kt)("li",{parentName:"ul"},"future markers ")),(0,i.kt)("p",null,"These lists for past markers and future markers are used to determine whether a message is in the past cone of the other, and the list for future markers also helps us to efficiently estimate the approval weight of a message."),(0,i.kt)("h4",{id:"structuredetails-structure"},"StructureDetails Structure"),(0,i.kt)("p",null,"StructureDetails is a structure that will be in the message metadata containing marker information."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Rank"),(0,i.kt)("td",{parentName:"tr",align:null},"uint64"),(0,i.kt)("td",{parentName:"tr",align:null},"The rank of the message.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"IsPastMarker"),(0,i.kt)("td",{parentName:"tr",align:null},"bool"),(0,i.kt)("td",{parentName:"tr",align:null},"A flag to indicate whether a message is a marker.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"PastMarkers"),(0,i.kt)("td",{parentName:"tr",align:null},"map","[SequenceID]","Index"),(0,i.kt)("td",{parentName:"tr",align:null},"PM list, a list of PMs from different sequences.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"FutureMarkers"),(0,i.kt)("td",{parentName:"tr",align:null},"map","[SequenceID]","Index"),(0,i.kt)("td",{parentName:"tr",align:null},"FM list, a list of FMs from different sequences.")))),(0,i.kt)("h5",{id:"past-markers"},"Past Markers"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"PM")," list of a marker contains the marker itself only."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"PM")," list of non-marker messages is inherited from its ",(0,i.kt)("strong",{parentName:"li"},"strong")," parents, with 2 steps:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"for a given sequence select only the nearest marker (i.e. the markers with the highest ",(0,i.kt)("inlineCode",{parentName:"li"},"MI"),"). Thus for every sequence from the parents there will be exactly one marker."),(0,i.kt)("li",{parentName:"ol"},"remove those that have been referenced by other markers from this set. ")))),(0,i.kt)("h5",{id:"future-markers"},"Future Markers"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"FM")," list of a message is empty at start and gets updated when a new marker directly or indirectly references it. The propagation of a ",(0,i.kt)("inlineCode",{parentName:"p"},"FM")," to its past cone (i.e. the update of the ",(0,i.kt)("inlineCode",{parentName:"p"},"FutureMarkers")," field in the encountered messages) does not continue beyond a message if:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"FM")," list of a message includes a previous marker of the same sequence;"),(0,i.kt)("li",{parentName:"ol"},"the message is the marker in the different sequence, we update the ",(0,i.kt)("inlineCode",{parentName:"li"},"FM")," list of that marker only.")),(0,i.kt)("h3",{id:"the-sequence"},"The Sequence"),(0,i.kt)("p",null,"Sequences are used to track the UTXO DAG branches, each branch corresponds to a sequence with a unique ",(0,i.kt)("inlineCode",{parentName:"p"},"SID"),", and the sequences form a DAG as well."),(0,i.kt)("h4",{id:"sequence-structure"},"Sequence Structure"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"id"),(0,i.kt)("td",{parentName:"tr",align:null},"uint64"),(0,i.kt)("td",{parentName:"tr",align:null},"The sequence identifier of the sequence.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"parentReferences"),(0,i.kt)("td",{parentName:"tr",align:null},"map","[uint64]","Thresholdmap"),(0,i.kt)("td",{parentName:"tr",align:null},"The marker referenced map of each parent marker.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"rank"),(0,i.kt)("td",{parentName:"tr",align:null},"uint64"),(0,i.kt)("td",{parentName:"tr",align:null},"The rank of the sequence in the marker DAG.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"highestIndex"),(0,i.kt)("td",{parentName:"tr",align:null},"uint64"),(0,i.kt)("td",{parentName:"tr",align:null},"The highest MI of the marker sequence.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"lowestIndex"),(0,i.kt)("td",{parentName:"tr",align:null},"uint64"),(0,i.kt)("td",{parentName:"tr",align:null},"The lowest MI of the sequence.")))),(0,i.kt)("h4",{id:"create-sequence"},"Create Sequence"),(0,i.kt)("p",null,"A new sequence is created when:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"there's a conflict in a UTXO branch."),(0,i.kt)("li",{parentName:"ol"},"the UTXO branches are aggregated."),(0,i.kt)("li",{parentName:"ol"},"UTXO branches are merged.")),(0,i.kt)("p",null,"Each new sequence starts from a new marker."),(0,i.kt)("h4",{id:"sequences"},"Sequences"),(0,i.kt)("p",null,"For whatever reason a sequence is created, we assign a new $SID = 1+max(referenceSequencesIdentifiers)$. To prevent assigning a new ",(0,i.kt)("inlineCode",{parentName:"p"},"SID")," when combining same sequences again, we build parents-child relation in a map if a new sequence is created. "),(0,i.kt)("h4",{id:"sequence-rank"},"Sequence Rank"),(0,i.kt)("p",null,"The rank of a sequence graph is the number of sequences from the starting point to itself. The sequence ranks are shown in the figure above."),(0,i.kt)("h2",{id:"example-1"},"Example 1"),(0,i.kt)("p",null,"Here is an example of how the markers and sequences structures would look in the Tangle:\nThe purple colored messages are markers."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Example 1",src:t(44218).Z,title:"Example 1"})),(0,i.kt)("h2",{id:"example-2-test-for-the-mapping-interaction-with-the-booker"},"Example 2: Test for the Mapping interaction with the Booker"),(0,i.kt)("p",null,"The Marker tool implementation is tested for correct Marker and Booker mapping. A transaction-by-transaction discussion of the test can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/goshimmer/blob/develop/packages/tangle/images/TestBookerMarkerMappings.md"},"here")," and can be viewed by opening the file locally in a browser. Transactions arrive in the order of the their transaction number. The end result and the values in the various fields is shown in the following figures:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Example 2.1",src:t(30005).Z,title:"Example 2.1"})),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Example 2.2",src:t(22544).Z,title:"Example 2.2"})),(0,i.kt)("h2",{id:"implementation-details"},"Implementation details"),(0,i.kt)("p",null,"In the following we describe some of the functions in more detail."),(0,i.kt)("h3",{id:"normalization-of-the-referenced-pms-and-sequences"},"Normalization of the referenced PMs and Sequences"),(0,i.kt)("p",null,"Messages can have markers from different sequences in ",(0,i.kt)("inlineCode",{parentName:"p"},"PM")," list and ",(0,i.kt)("inlineCode",{parentName:"p"},"FM")," list, the order and referenced relationship among sequences are important for example when it comes to inheriting the ",(0,i.kt)("inlineCode",{parentName:"p"},"PM")," list from parents. Thus, we need to track these sequences."),(0,i.kt)("p",null,"When a new sequence is created we check the parent marker' sequences with the function ",(0,i.kt)("inlineCode",{parentName:"p"},"normalizeMarkers()")," in order from high to low rank. In this function, we remove those ",(0,i.kt)("inlineCode",{parentName:"p"},"PM"),"s that it's belonging sequence is referenced by others."),(0,i.kt)("p",null,"An example is ",(0,i.kt)("strong",{parentName:"p"},"msg 10")," in the figure above, $","[0,2]",", ","[1,1]",", ","[2,3]","$ are ",(0,i.kt)("inlineCode",{parentName:"p"},"PM"),"s to be considered to inherit. $","[2,3]","$ is the first marker to check, since it has the highest sequence rank. We select the parent sequences of $","[2,3]","$, which are $0$ and $1$, and the referenced ",(0,i.kt)("inlineCode",{parentName:"p"},"PM"),"s therein. Next any ",(0,i.kt)("inlineCode",{parentName:"p"},"PM"),"s that are already referenced can be removed. This results in that the PMs of ",(0,i.kt)("strong",{parentName:"p"},"msg 10")," is $","[2,3]","$ only."),(0,i.kt)("p",null,"In the following we show the implementation of  ",(0,i.kt)("inlineCode",{parentName:"p"},"normalizeMarkers()"),", which returns the markers and sequences that will be inherited from a message."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// normalizeMarkers takes a set of Markers and removes each Marker that is already referenced by another Marker in the\n// same set (the remaining Markers are the "most special" Markers that reference all Markers in the set grouped by the\n// rank of their corresponding Sequence). In addition, the method returns all SequenceIDs of the Markers that were not\n// referenced by any of the Markers (the tips of the Sequence DAG).\nfunc (m *Manager) normalizeMarkers(markers *Markers) (normalizedMarkersByRank *markersByRank, normalizedSequences SequenceIDs) {\n    rankOfSequencesCache := make(map[SequenceID]uint64)\n\n    normalizedMarkersByRank = newMarkersByRank()\n    normalizedSequences = make(SequenceIDs)\n    // group markers with same sequence rank\n    markers.ForEach(func(sequenceID SequenceID, index Index) bool {\n        normalizedSequences[sequenceID] = types.Void\n        normalizedMarkersByRank.Add(m.rankOfSequence(sequenceID, rankOfSequencesCache), sequenceID, index)\n\n        return true\n    })\n    markersToIterate := normalizedMarkersByRank.Clone()\n\n    //iterate from highest sequence rank to lowest\n    for i := markersToIterate.HighestRank() + 1; i > normalizedMarkersByRank.LowestRank(); i-- {\n        currentRank := i - 1\n        markersByRank, rankExists := markersToIterate.Markers(currentRank)\n        if !rankExists {\n            continue\n        }\n\n        // for each marker from the current sequence rank check if we can remove a marker in normalizedMarkersByRank,\n        // and add the parent markers to markersToIterate if necessary\n        if !markersByRank.ForEach(func(sequenceID SequenceID, index Index) bool {\n            if currentRank <= normalizedMarkersByRank.LowestRank() {\n                return false\n            }\n\n            if !(&CachedSequence{CachedObject: m.sequenceStore.Load(sequenceID.Bytes())}).Consume(func(sequence *Sequence) {\n                // for each of the parentMarkers of this particular index\n                sequence.HighestReferencedParentMarkers(index).ForEach(func(referencedSequenceID SequenceID, referencedIndex Index) bool {\n                    // of this marker delete the referenced sequences since they are no sequence tips anymore in the sequence DAG\n                    delete(normalizedSequences, referencedSequenceID)\n\n                    rankOfReferencedSequence := m.rankOfSequence(referencedSequenceID, rankOfSequencesCache)\n                    // check whether there is a marker in normalizedMarkersByRank that is from the same sequence\n                    if index, indexExists := normalizedMarkersByRank.Index(rankOfReferencedSequence, referencedSequenceID); indexExists {\n                        if referencedIndex >= index {\n                            // this referencedParentMarker is from the same sequence as a marker in the list but with higher index - hence remove the index from the Marker list\n                            normalizedMarkersByRank.Delete(rankOfReferencedSequence, referencedSequenceID)\n\n                            // if rankOfReferencedSequence is already the lowest rank of the original markers list,\n                            // no need to add it since parents of the referencedMarker cannot delete any further elements from the list\n                            if rankOfReferencedSequence > normalizedMarkersByRank.LowestRank() {\n                                markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)\n                            }\n                        }\n\n                        return true\n                    }\n\n                    // if rankOfReferencedSequence is already the lowest rank of the original markers list,\n                    // no need to add it since parents of the referencedMarker cannot delete any further elements from the list\n                    if rankOfReferencedSequence > normalizedMarkersByRank.LowestRank() {\n                        markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)\n                    }\n\n                    return true\n                })\n            }) {\n                panic(fmt.Sprintf("failed to load Sequence with %s", sequenceID))\n            }\n\n            return true\n        }) {\n            return\n        }\n    }\n\n    return\n}\n')),(0,i.kt)("h3",{id:"markers-application-past-cone-check"},"Markers Application: Past Cone Check"),(0,i.kt)("p",null,"By comparing the past and future markers of messages, we can easily tell if one is in another's past cone. The function returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"TriBool")," representing the three possible statuses: ",(0,i.kt)("inlineCode",{parentName:"p"},"True"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," is returned, then we need to perform a search of the Tangle by walking by means of e.g. a Breadth-First Search."),(0,i.kt)("p",null,"In the following we show the implementation of the past cone check: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// IsInPastCone checks if the earlier Markers are directly or indirectly referenced by the later Markers.\nfunc (m *Manager) IsInPastCone(earlierMarkers *MarkersPair, laterMarkers *MarkersPair) (referenced TriBool) {\n    // fast check: if earlier Markers have larger highest Indexes they can\'t be in the past cone\n    if earlierMarkers.PastMarkers.HighestIndex() > laterMarkers.PastMarkers.HighestIndex() {\n        return False\n    }\n\n    // fast check: if earlier Marker is a past Marker and the later ones reference it we can return early\n    if earlierMarkers.IsPastMarker {\n        earlierMarker := earlierMarkers.PastMarkers.FirstMarker()\n        if earlierMarker == nil {\n            panic("failed to retrieve Marker")\n        }\n\n        if laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(earlierMarker.sequenceID); sequenceExists {\n            if laterIndex >= earlierMarker.index {\n                return True\n            }\n\n            return False\n        }\n\n        if laterMarkers.PastMarkers.HighestIndex() <= earlierMarker.index {\n            return False\n        }\n    }\n\n    if laterMarkers.IsPastMarker {\n        laterMarker := laterMarkers.PastMarkers.FirstMarker()\n        if laterMarker == nil {\n            panic("failed to retrieve Marker")\n        }\n\n        // if the earlier Marker inherited an Index of the same Sequence that is higher than the later we return false\n        if earlierIndex, sequenceExists := earlierMarkers.PastMarkers.Get(laterMarker.sequenceID); sequenceExists && earlierIndex >= laterMarker.index {\n            return False\n        }\n\n        // if the earlier Markers are referenced by a Marker of the same Sequence that is larger, we are not in the past cone\n        if earlierFutureIndex, earlierFutureIndexExists := earlierMarkers.FutureMarkers.Get(laterMarker.sequenceID); earlierFutureIndexExists && earlierFutureIndex > laterMarker.index {\n            return False\n        }\n\n        // if the earlier Markers were referenced by the same or a higher future Marker we are not in the past cone\n        // (otherwise we would be the future marker)\n        if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {\n            earlierIndex, similarSequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)\n            return !similarSequenceExists || earlierIndex < laterIndex\n        }) {\n            return False\n        }\n\n        if earlierMarkers.PastMarkers.HighestIndex() >= laterMarker.index {\n            return False\n        }\n    }\n\n    // if the highest Indexes of both past Markers are the same ...\n    if earlierMarkers.PastMarkers.HighestIndex() == laterMarkers.PastMarkers.HighestIndex() {\n        // ... then the later Markers should contain exact copies of all of the highest earlier Markers because parent\n        // Markers get inherited and if they would have been captured by a new Marker in between then the highest\n        // Indexes would no longer be the same\n        if !earlierMarkers.PastMarkers.ForEach(func(sequenceID SequenceID, earlierIndex Index) bool {\n            if earlierIndex == earlierMarkers.PastMarkers.HighestIndex() {\n                laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(sequenceID)\n                return sequenceExists && laterIndex != earlierIndex\n            }\n\n            return true\n        }) {\n            return False\n        }\n    }\n\n    if earlierMarkers.FutureMarkers.HighestIndex() == laterMarkers.FutureMarkers.HighestIndex() && false {\n        // the earlier future markers need to contain all later ones because if there would be another marker in between that shadows them the later future Marker would have a higher index\n        if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {\n            if laterIndex == laterMarkers.FutureMarkers.highestIndex {\n                earlierIndex, sequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)\n                return sequenceExists && earlierIndex == laterIndex\n            }\n\n            return true\n        }) {\n            return False\n        }\n    }\n\n    // detailed check: earlier marker is referenced by something that the later one references\n    if m.markersReferenceMarkers(laterMarkers.PastMarkers, earlierMarkers.FutureMarkers, false) {\n        return True\n    }\n\n    // detailed check: the\n    if m.markersReferenceMarkers(earlierMarkers.FutureMarkers, laterMarkers.PastMarkers, true) {\n        return Maybe\n    }\n\n    return False\n}\n\n')),(0,i.kt)("h3",{id:"markers-application-approval-weight-estimation"},"Markers Application: Approval Weight Estimation"),(0,i.kt)("p",null,"To approximate the approval weight of a message, we simply retrieve the approval weight of its ",(0,i.kt)("inlineCode",{parentName:"p"},"FM")," list. Since the message is in the past cone of its ",(0,i.kt)("inlineCode",{parentName:"p"},"FM"),"s, the approval weight and the finality will be at least the same as its ",(0,i.kt)("inlineCode",{parentName:"p"},"FM"),"s. This will of course be a lower bound (which is the \u201csafe\u201d bound), but if the markers are set frequently enough, it should be a good approximation."),(0,i.kt)("p",null,"For details of managing approval weight of each marker and approval weight calculation thereof please refer to ",(0,i.kt)("a",{parentName:"p",href:"/goshimmer/protocol_specification/consensus_mechanism#approval-weight-aw"},"Approval Weight"),"."))}m.isMDXComponent=!0},3905:function(e,r,t){t.d(r,{Zo:function(){return k},kt:function(){return h}});var n=t(67294);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function l(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=n.createContext({}),u=function(e){var r=n.useContext(o),t=r;return e&&(t="function"==typeof e?e(r):s(s({},r),e)),t},k=function(e){var r=u(e.components);return n.createElement(o.Provider,{value:r},e.children)},c={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},m=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,k=l(e,["components","mdxType","originalType","parentName"]),m=u(t),h=a,p=m["".concat(o,".").concat(h)]||m[h]||c[h]||i;return t?n.createElement(p,s(s({ref:r},k),{},{components:t})):n.createElement(p,s({ref:r},k))}));function h(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=m;var l={};for(var o in r)hasOwnProperty.call(r,o)&&(l[o]=r[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var u=2;u<i;u++)s[u]=t[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},44218:function(e,r,t){r.Z=t.p+"assets/images/example_1-670c675a90452a0642316170a5abe1f5.png"},30005:function(e,r,t){r.Z=t.p+"assets/images/example_2_1-00d77f7d9f884c458a80645806106665.png"},22544:function(e,r,t){r.Z=t.p+"assets/images/example_2_2-ce4881c2d64bda5d044b32087fb0c2eb.png"}}]);