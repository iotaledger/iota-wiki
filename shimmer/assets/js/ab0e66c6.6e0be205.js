"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[10765],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=i,d=c["".concat(l,".").concat(h)]||c[h]||u[h]||o;return n?a.createElement(d,r(r({ref:t},m),{},{components:n})):a.createElement(d,r({ref:t},m))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},77681:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const o={},r="Non-fungible Tokens",s={unversionedId:"explanations/ledger/nft",id:"explanations/ledger/nft",title:"Non-fungible Tokens",description:"A non-fungible token (NFT) is a globally unique token representing ownership of any distinct asset.",source:"@site/shimmer/external/introduction-docs/docs/explanations/ledger/nft.md",sourceDirName:"explanations/ledger",slug:"/explanations/ledger/nft",permalink:"/shimmer/introduction/explanations/ledger/nft",draft:!1,editUrl:"https://github.com/iotaledger/chrysalis-docs/edit/develop/docs/shimmer/external/introduction-docs/docs/explanations/ledger/nft.md",tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Native Tokens and Foundries",permalink:"/shimmer/introduction/explanations/ledger/foundry"},next:{title:"Node Software",permalink:"/shimmer/introduction/explanations/node_software"}},l={},p=[{value:"NFTs as native tokens?",id:"nfts-as-native-tokens",level:2},{value:"Minting an NFT",id:"minting-an-nft",level:2},{value:"Transferring NFT",id:"transferring-nft",level:2},{value:"Why can&#39;t NFT ID be set directly upon minting?",id:"why-cant-nft-id-be-set-directly-upon-minting",level:3},{value:"Transferring NFT with storage deposit return",id:"transferring-nft-with-storage-deposit-return",level:2},{value:"Claiming a conditional NFT transfer",id:"claiming-a-conditional-nft-transfer",level:2},{value:"Burning an NFT",id:"burning-an-nft",level:2},{value:"NFT as a wallet",id:"nft-as-a-wallet",level:2},{value:"Unlocking funds owned by the NFT",id:"unlocking-funds-owned-by-the-nft",level:3},{value:"Transferring NFT owned by the NFT",id:"transferring-nft-owned-by-the-nft",level:3},{value:"NFT Collections",id:"nft-collections",level:2},{value:"Creation of a Collection NFT",id:"creation-of-a-collection-nft",level:3},{value:"Minting NFTs within the collection",id:"minting-nfts-within-the-collection",level:3},{value:"Locking Collection NFT",id:"locking-collection-nft",level:3}],m={toc:p};function u(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"non-fungible-tokens"},"Non-fungible Tokens"),(0,i.kt)("p",null,"A non-fungible token (NFT) is a globally unique token representing ownership of any distinct asset.\nNon-fungible tokens are implemented in Stardust as a standalone output type called ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#nft-output"},(0,i.kt)("em",{parentName:"a"},"NFT Output")),".\nOnce minted, the ",(0,i.kt)("em",{parentName:"p"},"NFT Output")," gets assigned a unique ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," by the protocol based on the minting transaction. Issuers may\nchoose to define immutable properties on the output upon minting, such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#issuer-feature"},"issuer")," identity, namely the address of the issuer,"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#metadata-feature"},"metadata")," treated as binary data by the protocol.")),(0,i.kt)("p",null,"A distinct feature of L1 NFTs is the ability to function as standalone wallets. Each NFT owns an address derived from its\nunique ",(0,i.kt)("em",{parentName:"p"},"NFT ID"),", called ",(0,i.kt)("em",{parentName:"p"},"NFT Address"),". NFT addresses look pretty much like regular Ed25519 addresses when encoded in bech32,\nexcept they ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#address-unlock-condition"},"always start with"),"\nthe character ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," after the separator. (",(0,i.kt)("inlineCode",{parentName:"p"},"iota1z..."),", ",(0,i.kt)("inlineCode",{parentName:"p"},"smr1z..."),")."),(0,i.kt)("p",null,"If ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," is a protocol generated value, how can funds locked under the ",(0,i.kt)("em",{parentName:"p"},"NFT Address")," be unlocked in a transaction?\nThe trick is to prove ownership of the ",(0,i.kt)("em",{parentName:"p"},"NFT Output")," that defines ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," and hence ",(0,i.kt)("em",{parentName:"p"},"NFT Address"),". To unlock an output\nlocked to ",(0,i.kt)("em",{parentName:"p"},"NFT Address"),", the owner has to include the NFT itself in the transaction. If the unlock of the NFT output is valid,\nit means that the owner authorized the transaction, therefore it may consume further outputs locked under that ",(0,i.kt)("em",{parentName:"p"},"NFT Address"),"."),(0,i.kt)("p",null,"Once minted, only the owner of the ",(0,i.kt)("em",{parentName:"p"},"NFT Output")," may unlock it to include it in transactions. When an ",(0,i.kt)("em",{parentName:"p"},"NFT Output")," is unlocked\nin a transaction but the output side doesn't contain it, the NFT gets burned. Any funds locked under its address are lost\nforever, since it is impossible to recreate the same output with the same ",(0,i.kt)("em",{parentName:"p"},"NFT ID"),". Always check if the NFT owns something before burning it!"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"NFT Outputs")," support all possible (mutable) ",(0,i.kt)("em",{parentName:"p"},"Features")," and ",(0,i.kt)("em",{parentName:"p"},"Unlock Conditions"),", just like ",(0,i.kt)("em",{parentName:"p"},"Basic Outputs"),". Therefore,\nyou can define ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#timelock-unlock-condition"},"timelocks"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#expiration-unlock-condition"},"expiration"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#storage-deposit-return-unlock-condition"},"storage deposit return"),"\nconditions on NFTs, but also features like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#sender-feature"},"sender"),",\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#metadata-feature"},"metadata")," or ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#tag-feature"},"tag"),". With such a powerful feature set, NFTs become first-class citizens in the ledger and also support\nsmart contract chain interactions."),(0,i.kt)("h2",{id:"nfts-as-native-tokens"},"NFTs as native tokens?"),(0,i.kt)("p",null,"The alert reader might be wondering: can't we just set the maximum supply of a ",(0,i.kt)("a",{parentName:"p",href:"/shimmer/introduction/explanations/ledger/foundry"},"native token")," to one to have a unique native token, therefore an NFT?\nThe answer is yes, we could do that, but this approach has its limitations compared to the output based approach:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"NFTs link the actual owned asset via metadata to the token. Metadata of a native token sits in the foundry output,\nwhile the native token itself may reside in any other output. Therefore, the NFT and its metadata are detached from each other."),(0,i.kt)("li",{parentName:"ul"},"The owner of the NFT as a native token has no control of the foundry, therefore it is impossible to melt the native token\nwithout the involvement of the issuer. The owner may still burn it, but then the storage deposit of the foundry can never be refunded."),(0,i.kt)("li",{parentName:"ul"},"Native tokens can not own other asset in the ledger.")),(0,i.kt)("h2",{id:"minting-an-nft"},"Minting an NFT"),(0,i.kt)("p",null,"Transaction A displays the minting of an NFT on protocol level. For the sake of simplicity, we only define an immutable\nissuer and metadata upon minting, but it would be possible to add any unlock conditions or mutable feature as well."),(0,i.kt)("p",null,"Minting must respect the following constraints:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"NFT ID")," must be zeroed out. The protocol will replace it with the blake2b-256 hash of the ",(0,i.kt)("em",{parentName:"li"},"Output ID")," upon booking."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Issuer")," address must be unlocked on the input side,"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Immutable Metadata")," length must not exceed ",(0,i.kt)("em",{parentName:"li"},"Maximum Metadata Length")," defined in ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/Wollac/protocol-rfcs/blob/protocol-parameters/tips/TIP-0022/tip-0022.md"},"TIP-22 (IOTA)")," or ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/iotaledger/tips/blob/shimmer-params/tips/TIP-0032/tip-0032.md"},"TIP-32 (Shimmer)"),".")),(0,i.kt)("p",null,"It is recommended to use one of the ",(0,i.kt)("em",{parentName:"p"},"IRC")," standards to define NFT metadata. See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Kami-Labs/tips/blob/main/tips/TIP-0027/tip-0027.md"},"IRC-27"),"\nfor instance on how to define basic metadata linked to the NFT."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction A - Minting an NFT",src:n(65417).Z,width:"842",height:"1012"})),(0,i.kt)("h2",{id:"transferring-nft"},"Transferring NFT"),(0,i.kt)("p",null,"Transaction B sends the newly issued ",(0,i.kt)("em",{parentName:"p"},"NFT Output #1")," to the ",(0,i.kt)("em",{parentName:"p"},"recipient"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"NFT ID")," is all zeros in ",(0,i.kt)("em",{parentName:"li"},"NFT Output #1"),", since it has just been minted in Transaction A. While the value of the field (",(0,i.kt)("a",{parentName:"li",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#additional-transaction-semantic-validation-rules-3"},"explicit NFT ID"),") is\nall zeroes, based on the protocol rules we know that the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/lzpap/tips/blob/master/tips/TIP-0018/tip-0018.md#additional-transaction-semantic-validation-rules-3"},"implicit NFT ID"),"\ncan be calculated from the ",(0,i.kt)("em",{parentName:"li"},"Output ID")," of ",(0,i.kt)("em",{parentName:"li"},"NFT Output #1"),"."),(0,i.kt)("li",{parentName:"ul"},"When the minted NFT is transferred for the first time, ",(0,i.kt)("em",{parentName:"li"},"NFT ID")," must be set as the implicit NFT ID of the mint output. Therefore, ",(0,i.kt)("em",{parentName:"li"},"NFT Output #2"),"\nsets the value of the ",(0,i.kt)("em",{parentName:"li"},"NFT ID")," field as the blake2b-256 hash of ",(0,i.kt)("em",{parentName:"li"},"NFT Output #1 ID"),". If you miss this step and leave it as all zeroes,\nthe protocol interprets the transaction as the burning of the minted NFT and the creation of a new NFT."),(0,i.kt)("li",{parentName:"ul"},"Notice, that the immutable features are not allowed to change. Their values are carried together with the NFT until it is burned."),(0,i.kt)("li",{parentName:"ul"},"To change ownership of the NFT, unlock the address of the ",(0,i.kt)("em",{parentName:"li"},"Address Unlock Condition")," (",(0,i.kt)("em",{parentName:"li"},"owner"),") in the transaction and set a new one (",(0,i.kt)("em",{parentName:"li"},"recipient"),") on the output side."),(0,i.kt)("li",{parentName:"ul"},"Without further unlock conditions, ",(0,i.kt)("em",{parentName:"li"},"owner")," loses the 100i storage deposit which is now controlled by ",(0,i.kt)("em",{parentName:"li"},"recipient"),". When an NFT is sold via a marketplace, it is the\nplatform that decides how to handle the storage deposit, whether the buying price accounts for it or the owner should be refunded by the recipient via a ",(0,i.kt)("em",{parentName:"li"},"Storage Deposit Return Unlock Condition"),".")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction B - Transferring NFT",src:n(27353).Z,width:"842",height:"892"})),(0,i.kt)("h3",{id:"why-cant-nft-id-be-set-directly-upon-minting"},"Why can't NFT ID be set directly upon minting?"),(0,i.kt)("p",null,"It was shown in Transaction A that ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," must be zeroed out on minting, and via Transaction B that it has to be set to\nthe protocol generated value in the first transfer. The reason for this is the chicken and egg situation rooted in how\nunique values are generated on protocol level:"),(0,i.kt)("p",null,"Unique ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," is computed from ",(0,i.kt)("em",{parentName:"p"},"Output ID"),", that is computed from the minting transaction content. The transaction content contains\nthe value of the ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," field of the output. On minting, the ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," is set to zero to signal the minting operation. As soon as the transaction is\nprepared (don't even need to submit it yet) the ",(0,i.kt)("em",{parentName:"p"},"Output ID")," is known. Therefore, ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," can be computed locally, but\nit is not possible to place it inside the minting output, as that would alter the transaction content, hence the ",(0,i.kt)("em",{parentName:"p"},"Output ID"),"\nand the ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," itself."),(0,i.kt)("h2",{id:"transferring-nft-with-storage-deposit-return"},"Transferring NFT with storage deposit return"),(0,i.kt)("p",null,"Transaction C shows a conditional transfer of an NFT. By defining a ",(0,i.kt)("em",{parentName:"p"},"Storage Deposit Return Unlock Condition")," and an\n",(0,i.kt)("em",{parentName:"p"},"Expiration Unlock Condition"),", the recipient has to claim the NFT transfer in a transaction that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Refunds the storage deposit to the ",(0,i.kt)("em",{parentName:"li"},"owner")," address,"),(0,i.kt)("li",{parentName:"ul"},"within the timeframe specified in the expiration condition.")),(0,i.kt)("p",null,"Should the recipient fail to claim the transfer in time, the ownership of ",(0,i.kt)("em",{parentName:"p"},"NFT Output #3")," falls back to the ",(0,i.kt)("em",{parentName:"p"},"owner"),"\naddress defined in the ",(0,i.kt)("em",{parentName:"p"},"Expiration Unlock Condition"),". An expired output can be unlocked by this address without having\nto fulfill the ",(0,i.kt)("em",{parentName:"p"},"Storage Deposit Return Unlock Condition"),"."),(0,i.kt)("p",null,"Transaction C defines that ",(0,i.kt)("em",{parentName:"p"},"recipient")," has to claim the output in a transaction such that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"owner")," is refunded with 100i via a ",(0,i.kt)("em",{parentName:"li"},"Basic Output"),","),(0,i.kt)("li",{parentName:"ul"},"the claiming transaction may only be carried out until ",(0,i.kt)("em",{parentName:"li"},"May 24 2022 18:00:00"),".")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction C - Transferring NFT with storage deposit return",src:n(41128).Z,width:"842",height:"982"})),(0,i.kt)("h2",{id:"claiming-a-conditional-nft-transfer"},"Claiming a conditional NFT transfer"),(0,i.kt)("p",null,"Transaction D shows how ",(0,i.kt)("em",{parentName:"p"},"recipient")," can claim the conditional transfer initiated in Transaction C:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"recipient")," has to fund the transaction with the to-be refunded storage deposit, therefore ",(0,i.kt)("em",{parentName:"li"},"Basic Output #2")," is unlocked\non the input side."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"NFT Output #4")," removes the additional unlocks from the NFT and places it solely into the ownership of ",(0,i.kt)("em",{parentName:"li"},"recipient"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Basic Output #3")," refunds ",(0,i.kt)("em",{parentName:"li"},"owner")," with the storage deposit defined in the ",(0,i.kt)("em",{parentName:"li"},"Storage Deposit Return Unlock Condition")," of\n",(0,i.kt)("em",{parentName:"li"},"NFT Output #3"),"."),(0,i.kt)("li",{parentName:"ul"},"Transaction D is only valid if the confirming milestone has a timestamp earlier than the one defined in the\n",(0,i.kt)("em",{parentName:"li"},"Expiration Unlock Condition")," of ",(0,i.kt)("em",{parentName:"li"},"NFT Output #3"),"."),(0,i.kt)("li",{parentName:"ul"},"Since both ",(0,i.kt)("em",{parentName:"li"},"NFT Output #3")," and ",(0,i.kt)("em",{parentName:"li"},"Basic Output #2")," are unlocked by ",(0,i.kt)("em",{parentName:"li"},"recipient")," address, it is enough to sign the transaction\nonce in ",(0,i.kt)("em",{parentName:"li"},"Signature Unlock #1")," and reference this unlock in ",(0,i.kt)("em",{parentName:"li"},"Reference Unlock #2"),".")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction D - Claiming a conditional NFT transfer",src:n(36762).Z,width:"842",height:"1682"})),(0,i.kt)("h2",{id:"burning-an-nft"},"Burning an NFT"),(0,i.kt)("p",null,"The owner of the NFT may choose to burn it to retrieve the storage deposit of the ",(0,i.kt)("em",{parentName:"p"},"NFT Output"),". Burning on protocol\nlevel simply means that the ",(0,i.kt)("em",{parentName:"p"},"NFT Output")," is unlocked in a transaction, but it doesn't appear on the output side."),(0,i.kt)("p",null,"Transaction E shows how to burn an NFT and claim its storage deposit into a ",(0,i.kt)("em",{parentName:"p"},"Basic Output"),"."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Before burning an NFT, always check whether its ",(0,i.kt)("em",{parentName:"p"},"NFT Address")," owns something in the ledger. Otherwise, you may lose those\nfunds forever!")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction E - Burning an NFT",src:n(3957).Z,width:"842",height:"892"})),(0,i.kt)("h2",{id:"nft-as-a-wallet"},"NFT as a wallet"),(0,i.kt)("p",null,"Each NFT has its own unique ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," that also functions as an address on protocol level. The address can be deterministically\ngenerated from the ID as outlined in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/tips/blob/main/tips/TIP-0031/tip-0031.md"},"TIP-31"),", basically\nprepending ",(0,i.kt)("em",{parentName:"p"},"NFT ID")," with the ",(0,i.kt)("em",{parentName:"p"},"NFT Address Type")," and encoding it as a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki"},"Bech32")," string."),(0,i.kt)("p",null,"What this means is that any output (except for a foundry) can be locked to an ",(0,i.kt)("em",{parentName:"p"},"NFT Address")," in the protocol. An ",(0,i.kt)("em",{parentName:"p"},"NFT Address"),"\nis a first class citizen on protocol level, just like an ",(0,i.kt)("em",{parentName:"p"},"Ed25519 Address"),"."),(0,i.kt)("p",null,"To unlock outputs locked under an ",(0,i.kt)("em",{parentName:"p"},"NFT Address"),", the owner of the NFT must also unlock the ",(0,i.kt)("em",{parentName:"p"},"NFT Output")," that defines it,\nhence proving ownership of the address. Note, that this is a significant difference compared to ",(0,i.kt)("em",{parentName:"p"},"Ed25519 Addresses"),", where\nownership is proved via a signing the transaction with a private key"),(0,i.kt)("h3",{id:"unlocking-funds-owned-by-the-nft"},"Unlocking funds owned by the NFT"),(0,i.kt)("p",null,"Transaction F shows how one can unlock an output locked to an ",(0,i.kt)("em",{parentName:"p"},"NFT Address"),". Notice, that ",(0,i.kt)("em",{parentName:"p"},"Basic Output #4")," contains\nnot only base tokens, but also native tokens. An ",(0,i.kt)("em",{parentName:"p"},"NFT Output")," supports holding these native token directly in the output itself,\nbut it would also be possible to place them in any output after ",(0,i.kt)("em",{parentName:"p"},"Basic Output #4")," is unlocked. It is the decision of the\nowner of the NFT to define what outputs to create in the transaction."),(0,i.kt)("p",null,"Just like any other output, an ",(0,i.kt)("em",{parentName:"p"},"NFT Output")," supports holding up to ",(0,i.kt)("em",{parentName:"p"},"Max Native Token Count")," (defined in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Wollac/protocol-rfcs/blob/protocol-parameters/tips/TIP-0022/tip-0022.md#detailed-design"},"TIP-22")," for IOTA and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/tips/blob/shimmer-params/tips/TIP-0032/tip-0032.md#global-parameters"},"TIP-32")," for Shimmer).\nIn case you need to store more native tokens, distribute them in ",(0,i.kt)("em",{parentName:"p"},"Basic Outputs")," that are owned by the NFT."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction F - Unlocking funds owned by the NFT",src:n(9850).Z,width:"843",height:"1362"})),(0,i.kt)("h3",{id:"transferring-nft-owned-by-the-nft"},"Transferring NFT owned by the NFT"),(0,i.kt)("p",null,"So far in the examples the NFTs were always owned by a private key backed address, therefore they were unlocked via a signature.\nWhat happens when an NFT is owned by another NFT?"),(0,i.kt)("p",null,'Similarly to Transaction F, the NFT that owns the other one must be unlocked in the transaction to prove the ownership.\nTransaction G shows how the "owner NFT" can unlock the "owned NFT" and transfer it to a new recipient.'),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction G - Transferring NFT owned by the NFT",src:n(63348).Z,width:"842",height:"1532"})),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"It is possible to introduce circular ownership with ",(0,i.kt)("em",{parentName:"p"},"NFT Addresses")," (and also with ",(0,i.kt)("em",{parentName:"p"},"Alias Addresses"),"). In such a case,\nNFT A is owned by NFT B, while NFT B is owned by NFT A. This would mean that unlocking them in a transaction doesn't\nrequire a signature, therefore anyone could unlock them that leads to race conditions on protocol level."),(0,i.kt)("p",{parentName:"admonition"},"To prevent this undesired property, the protocol forces an ",(0,i.kt)("em",{parentName:"p"},"NFT Unlock")," to only be able to reference a previous ",(0,i.kt)("em",{parentName:"p"},"Unlock"),". As a result,\ncircular ownership becomes a deadlock, as neither NFTs can be unlocked anymore."),(0,i.kt)("p",{parentName:"admonition"},"Wallets and applications should implement mitigation strategies to prevent a deadlock: always perform circular ownership\nchecks before sending an NFT to another NFT!")),(0,i.kt)("h2",{id:"nft-collections"},"NFT Collections"),(0,i.kt)("p",null,"NFTs rarely exist in isolation, usually they are part of a bigger set, a collection. In smart contract based NFTs like ERC1155, a\ncollection and the NFTs in it are all tracked in a single contract. In UTXO based systems like IOTA/Shimmer however this\nis not possible, so a new way of linking together NFTs is needed."),(0,i.kt)("p",null,"Stardust protocol allows linking NFTs together via the ",(0,i.kt)("em",{parentName:"p"},"Issuer Feature"),". Since NFTs are first class citizens in the protocol,\nthey can function as issuers themselves. This feature is exploited for L1 NFT collections."),(0,i.kt)("h3",{id:"creation-of-a-collection-nft"},"Creation of a Collection NFT"),(0,i.kt)("p",null,"A Collection NFT is a just a normal ",(0,i.kt)("em",{parentName:"p"},"NFT Output")," but with special purpose: it is used to mint all NFTs in the collection.\nThe Collection NFT becomes the ",(0,i.kt)("em",{parentName:"p"},"Issuer")," of the ",(0,i.kt)("em",{parentName:"p"},"NFT Outputs")," representing NFTs within the collection."),(0,i.kt)("p",null,"It is possible to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Permanently lock the Collection NFT to prevent any future minting. No diluting is ever possible by issuers."),(0,i.kt)("li",{parentName:"ul"},"Lock the Collection NFT for some time to prevent minting,"),(0,i.kt)("li",{parentName:"ul"},"Deposit the Collection NFT into a L2 chain where minting activity can be governed via smart contracts or DAOs.")),(0,i.kt)("p",null,"Transaction H mints a Collection NFT the same way as Transaction A mints a regular one. The metadata makes it clear\nthat the intended use of this NFT is to serve as a Collection NFT."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"name")," defines the name of the collection,"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"uri")," points to a website with more information about the project. Note, that ",(0,i.kt)("em",{parentName:"li"},"type")," defines the resource type for ",(0,i.kt)("em",{parentName:"li"},"uri"),".")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction H - Creation of a Collection NFT",src:n(29432).Z,width:"842",height:"1022"})),(0,i.kt)("h3",{id:"minting-nfts-within-the-collection"},"Minting NFTs within the collection"),(0,i.kt)("p",null,"NFTs within the collection must be minted in a way that their ",(0,i.kt)("em",{parentName:"p"},"issuer")," is the Collection NFT. Therefore, we include\n",(0,i.kt)("em",{parentName:"p"},"NFT Output #10"),", the freshly minted Collection NFT from Transaction H in Transaction J, and define the ",(0,i.kt)("em",{parentName:"p"},"Issuer Feature"),"\nof all minted NFTs to hold the ",(0,i.kt)("em",{parentName:"p"},"NFT Address")," of the Collection NFT."),(0,i.kt)("p",null,"We also place unique metadata in each NFT within the collection. The metadata is formatted according to IRC27 and contains\ninformation about:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"where the asset represented by the NFT resides,"),(0,i.kt)("li",{parentName:"ul"},"the issuer or artist,"),(0,i.kt)("li",{parentName:"ul"},"the collection the NFT belongs to,"),(0,i.kt)("li",{parentName:"ul"},"optional royalty addresses,"),(0,i.kt)("li",{parentName:"ul"},"and custom attributes.")),(0,i.kt)("p",null,"Transaction J mints a very limited collection, there are only 3 items ",(0,i.kt)("em",{parentName:"p"},"NFT Output #12, #13 and #14"),". The issuer must\nalso provide the storage deposit for the newly minted NFTs, therefore ",(0,i.kt)("em",{parentName:"p"},"Basic Output #7")," is consumed in the transaction."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction J - Minting NFTs within the collection",src:n(97742).Z,width:"842",height:"2832"})),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"If you need to mint more than ",(0,i.kt)("em",{parentName:"p"},"Max Outputs Count")," (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Wollac/protocol-rfcs/blob/protocol-parameters/tips/TIP-0022/tip-0022.md#detailed-design"},"TIP-22")," IOTA, ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/tips/blob/shimmer-params/tips/TIP-0032/tip-0032.md#global-parameters"},"TIP-32")," Shimmer) NFTs, you must do it via chaining together more transactions.")),(0,i.kt)("p",null,"Once the minting transaction confirms, it is possible to fetch all NFT outputs within the collection via the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/tips/blob/indexer-api/tips/TIP-0026/tip-0026.md"},"Indexer API TIP-26"),". The following query returns all NFT outputs (their ",(0,i.kt)("em",{parentName:"p"},"Output IDs"),")\nthat have been issued by the Collection NFT:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"GET <indexer-base-url>/api/indexer/v1/outputs/nft?issuer=<collection-nft-address>\n")),(0,i.kt)("h3",{id:"locking-collection-nft"},"Locking Collection NFT"),(0,i.kt)("p",null,"The best way to ensure scarcity of collections is to prevent future minting activity. It is possible to lock the\nCollection NFT in the ledger for some time via a ",(0,i.kt)("em",{parentName:"p"},"Timelock Unlock Condition"),", or for eternity by sending it to the zero address."),(0,i.kt)("p",null,"The zero address is an Ed25519 address where the hash of the Ed255129 public key is all zeroes, therefore there exists no\nprivate key that could successfully unlock it."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Transaction K - Locking Collection NFT",src:n(917).Z,width:"842",height:"922"})))}u.isMDXComponent=!0},65417:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_A-3fc873c67629174f02f28531ae53fb25.svg"},27353:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_B-f53d2fd7027452533d7343ff15745748.svg"},41128:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_C-ff1604acf28e96f239ba9b7681b06f74.svg"},36762:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_D-607def1f24ceede9d8f259b6c35eb517.svg"},3957:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_E-ef969f71761b9205ad8ac57c0da0bf53.svg"},9850:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_F-3fcab324b3b49337874eebaaf2ebccb0.svg"},63348:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_G-bae12393c5cbdc7bc25d4deb215db757.svg"},29432:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_H-8857ab4c53a37bb731188a1a4bc3575b.svg"},97742:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_J-44e4ee7d7f2ce4c42d278f80d1371ffe.svg"},917:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tx_K-720072da4998b28544dcff7c651b8806.svg"}}]);