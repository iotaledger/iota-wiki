"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[95551],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),m=l(n),p=r,h=m["".concat(s,".").concat(p)]||m[p]||d[p]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},55247:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={keywords:["functions","views","Funcs","ScFuncContext","ScViewContext","ScExports"],description:"The function call context is a predefined parameter to each smart contract function, which allows you to access the functionality that the host sandbox interface provides.",image:"/img/logo/WASP_logo_dark.png"},i="Function Call Context",c={unversionedId:"guide/wasm_vm/context",id:"guide/wasm_vm/context",title:"Function Call Context",description:"The function call context is a predefined parameter to each smart contract function, which allows you to access the functionality that the host sandbox interface provides.",source:"@site/shimmer/external/wasp/documentation/docs/guide/wasm_vm/context.mdx",sourceDirName:"guide/wasm_vm",slug:"/guide/wasm_vm/context",permalink:"/shimmer/smart-contracts/guide/wasm_vm/context",draft:!1,editUrl:"https://github.com/iotaledger/wasp/edit/master/documentation/shimmer/external/wasp/documentation/docs/guide/wasm_vm/context.mdx",tags:[],version:"current",frontMatter:{keywords:["functions","views","Funcs","ScFuncContext","ScViewContext","ScExports"],description:"The function call context is a predefined parameter to each smart contract function, which allows you to access the functionality that the host sandbox interface provides.",image:"/img/logo/WASP_logo_dark.png"},sidebar:"tutorialSidebar",previous:{title:"Smart Contract Concepts",permalink:"/shimmer/smart-contracts/guide/wasm_vm/concepts"},next:{title:"Smart Contract Schema Tool",permalink:"/shimmer/smart-contracts/guide/wasm_vm/schema"}},s={},l=[],u={toc:l};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"function-call-context"},"Function Call Context"),(0,r.kt)("p",null,"Due to the sandboxed nature of Wasm code, it needs a host which runs the Wasm Virtual\nMachine (VM) that is able to load and execute the Wasm code. The host also provides the\nWasm code with restricted access to the host environment. These restrictions make the host\ninterface itself sandboxed as well. Smart contracts will only be able to call certain host\nfunctionality, depending on the ",(0,r.kt)("em",{parentName:"p"},"function call context"),"."),(0,r.kt)("p",null,"We distinguish between two types of smart contract function calls:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Func"),", which allows full mutable access to the smart contract state, and always\nresults in a state update. Funcs can be initiated through on-ledger and off-ledger\nrequests. A call to a Func is only complete once the associated state update has been\nregistered in the ledger (Tangle)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"View"),", which allows only limited, immutable access to the smart contract state, and\ntherefore does not result in a state update. Views are always initiated through\noff-ledger function calls. Since they do not require a state update on the ledger they\ncan be used to efficiently query the current state of the smart contract.")),(0,r.kt)("p",null,"To support this function call type distinction, Func and View functions each receive a\nseparate, different function call context through WasmLib. Only the functionality that is\nnecessary for their implementation can be accessed through their respective WasmLib\ncontexts, ",(0,r.kt)("inlineCode",{parentName:"p"},"ScFuncContext")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ScViewContext"),". ScViewContext provides a limited, immutable\nsubset of the full functionality provided by ScFuncContext. By having separate context\ntypes, compile-time type-checking can easily be used to enforce these usage constraints."),(0,r.kt)("h1",{id:"smart-contract-setup"},"Smart Contract Setup"),(0,r.kt)("p",null,"An important part of setting up a smart contract is defining exactly which Funcs and Views\nare available and informing the host about them through WasmLib. The host will have to be\nable to dispatch requested function calls to the corresponding smart contract code and\nwill have to apply any restrictions necessary to prevent Views from accidentally accessing\nfull Func functionality."),(0,r.kt)("p",null,"Another important part is to define for each function exactly what parameters and return\nvalues are expected/available, if any. The ISC stores parameter, state, and result values\nin simple dictionaries, with both keys and values being arbitrary byte strings. Normally,\nprogramming languages provide a much richer set of data types, which means that these data\ntypes will need to be serialized and deserialized correctly and consistently. WasmLib\nprovides a rich set of (de)serialization functions specifically for this purpose"),(0,r.kt)("p",null,"Even though it is definitely possible for a contract creator to directly use WasmLib to\nachieve his goals, we decided to provide a ",(0,r.kt)("em",{parentName:"p"},"Schema")," tool, which can be used to\nautomatically generate and update the entire smart contract framework code in the desired\nlanguage in a consistent and type-safe way."),(0,r.kt)("p",null,"In the next section we will introduce this ",(0,r.kt)("a",{parentName:"p",href:"/shimmer/smart-contracts/guide/wasm_vm/schema"},(0,r.kt)("inlineCode",{parentName:"a"},"Smart Contract Schema Tool")),"."))}d.isMDXComponent=!0}}]);