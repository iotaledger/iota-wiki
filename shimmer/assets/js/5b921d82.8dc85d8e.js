"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[12420],{3905:(e,t,o)=>{o.d(t,{Zo:()=>h,kt:()=>u});var a=o(67294);function n(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){n(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,a,n=function(e,t){if(null==e)return{};var o,a,n={},r=Object.keys(e);for(a=0;a<r.length;a++)o=r[a],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)o=r[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var c=a.createContext({}),l=function(e){var t=a.useContext(c),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},h=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var o=e.components,n=e.mdxType,r=e.originalType,c=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),m=l(o),u=n,p=m["".concat(c,".").concat(u)]||m[u]||d[u]||r;return o?a.createElement(p,i(i({ref:t},h),{},{components:o})):a.createElement(p,i({ref:t},h))}));function u(e,t){var o=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=o.length,i=new Array(r);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var l=2;l<r;l++)i[l]=o[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,o)}m.displayName="MDXCreateElement"},16670:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=o(87462),n=(o(67294),o(3905));const r={description:"Learn about Stronghold as a concurrent software, the actor model STM with TL2 and RLU.",image:"/img/logo/Stronghold_icon.png",keywords:["actor model","rlu","STM","concurrency","lockless","explanation"]},i="Concurrency in Stronghold",s={unversionedId:"explanations/concurrency",id:"explanations/concurrency",title:"Concurrency in Stronghold",description:"Learn about Stronghold as a concurrent software, the actor model STM with TL2 and RLU.",source:"@site/shimmer/external/stronghold.rs/develop/documentation/docs/explanations/concurrency.md",sourceDirName:"explanations",slug:"/explanations/concurrency",permalink:"/shimmer/stronghold.rs/explanations/concurrency",draft:!1,editUrl:"https://github.com/iotaledger/stronghold/edit/dev/documentation/shimmer/external/stronghold.rs/develop/documentation/docs/explanations/concurrency.md",tags:[],version:"current",frontMatter:{description:"Learn about Stronghold as a concurrent software, the actor model STM with TL2 and RLU.",image:"/img/logo/Stronghold_icon.png",keywords:["actor model","rlu","STM","concurrency","lockless","explanation"]},sidebar:"mySidebar",previous:{title:"Runtime Extensions",permalink:"/shimmer/stronghold.rs/explanations/runtime-extensions"},next:{title:"Deadlock Analysis in Stronghold",permalink:"/shimmer/stronghold.rs/explanations/deadlock-analysis"}},c={},l=[{value:"The Actor Model",id:"the-actor-model",level:2},{value:"Why didn&#39;t we keep the actor model?",id:"why-didnt-we-keep-the-actor-model",level:3},{value:"Software Transactional Memory (STM) with Transactional Locking 2 (TL2)",id:"software-transactional-memory-stm-with-transactional-locking-2-tl2",level:2},{value:"TL2",id:"tl2",level:3},{value:"Read-Log-Update (RLU)",id:"read-log-update-rlu",level:2},{value:"Concurrent Programming with Locks",id:"concurrent-programming-with-locks",level:2}],h={toc:l};function d(e){let{components:t,...o}=e;return(0,n.kt)("wrapper",(0,a.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"concurrency-in-stronghold"},"Concurrency in Stronghold"),(0,n.kt)("p",null,"Writing software that runs on CPUs with more than one core is the norm nowadays. Software libraries heavily use concurrent code, separating sequential steps of work into concurrent, possibly parallel, work packages."),(0,n.kt)("p",null,"Writing concurrent programs makes the most of our current computers and servers in terms of performance. The downside of this approach is that it is difficult to write such programs without having bugs. This is mostly due to a problem called ",(0,n.kt)("em",{parentName:"p"},"data race"),", where multiple threads simultaneously tamper with the same shared memory, which may create inconsistent behavior of the concurrent program because each thread executes its computations in a non-deterministic order."),(0,n.kt)("p",null,"Multiple solutions to tackle concurrent programming exist, and we have been exploring them for Stronghold.\nIn the following sections, we will present different solutions tested to make Stronghold a concurrent library."),(0,n.kt)("h2",{id:"the-actor-model"},"The Actor Model"),(0,n.kt)("p",null,"Stronghold employed a well-known concurrency architecture: the actor model. The basic idea of the actor model is to have isolated actors, each taking care of some functionality. Actors receive messages with data to act upon and return data when they finish processing it. Since each actor contains its own state and concurrency is achieved by not directly calling functions, but by polling messages, most undesirable concurrency problems are taken care of. Deadlocks will never occur."),(0,n.kt)("p",null,"The actor system is almost ubiquitous in the target architecture. Many modern languages have a built-in actor model with an excellent supervisor, among other tools. With Rust, the integration involves a lot of boilerplate code. But it\u2019s for each user to decide whether or not the actor model approach is favorable. We wanted to know whether we could provide a simple interface, ideally some primitive types to work on with simple function calls, but still run in a concurrent setup without the headaches that come with locks and mutexes."),(0,n.kt)("h3",{id:"why-didnt-we-keep-the-actor-model"},"Why didn't we keep the actor model?"),(0,n.kt)("p",null,"The first iteration of Stronghold implemented the actor model with the rust crate ",(0,n.kt)("a",{parentName:"p",href:"https://riker.rs/"},"Riker"),", an actor system crate."),(0,n.kt)("p",null,"Unfortunately, since this crate was discontinued, we had to find an alternative: the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/actix/actix"},"Actix")," actor framework crate.\nActix uses the Tokio runtime, which came as an issue for us as the Stronghold library."),(0,n.kt)("p",null,"Software using Stronghold had to pass ownership of the runtime to our code when making function calls to the Stronghold library.\nThis was cumbersome for our users, and we abandoned the idea of using the actor model for concurrent programming and explored other paradigms."),(0,n.kt)("h2",{id:"software-transactional-memory-stm-with-transactional-locking-2-tl2"},"Software Transactional Memory (STM) with Transactional Locking 2 (TL2)"),(0,n.kt)("p",null,"STMs have been around for quite some time. In STMs, each operation on memory happens in an atomic transaction. Whenever memory is modified, this modification is written into a log. While inside a transaction, reading from memory is also done through a log. The transaction has finished when all changes recorded inside the log have been committed to the actual memory. A transaction fails if another thread tries to modify the targeted piece of memory between operations. A failed transaction can be re-run any number of times."),(0,n.kt)("p",null,"This approach guarantees that modifications to memory are always consistent, but it comes with a restriction. Since transactions can be retried, operations inside a transaction must be idempotent and should not have any side effects. In an extreme case, think of a function that launches an ICMB: you can not reverse the process. Another edge case concerning STM-based approaches is interleaving transactions, where reads and writes are alternating between two threads. In a worst-case scenario, both transactions would retry indefinitely."),(0,n.kt)("h3",{id:"tl2"},"TL2"),(0,n.kt)("p",null,"The Implementation of TL2 is inspired by these papers:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.811&rank=4&q=various%20cross%20version%20operation&osm=&ossid="},"Transactional Locking II (2006)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.researchgate.net/publication/220854689_Testing_patterns_for_software_transactional_memory_engines"},"Testing patterns for software transactional memory engines"),".")),(0,n.kt)("p",null,"The idea is quite straightforward. A global clock is used and incremented every time a transaction terminates.\nShared memory/variables are tagged with a local clock value corresponding to the moment they were last modified by a transaction commitment.\nTransactions are computed on copies of these shared memory/variables."),(0,n.kt)("p",null,"At the end of each transaction, the system needs to check that all the shared memory/variables used during the transaction have not been tampered with by another transaction to keep a consistent behavior.\nStronghold verifies this by checking the local clock of the copies used for the transaction against the local clock of the original shared memory/variables."),(0,n.kt)("p",null,"If the check detects any inconsistency between clock values, then the transaction is reset and computed again."),(0,n.kt)("p",null,"If the check is successful, the copies are committed and replace the original shared memory/variables, and the global clock also gives them a new local clock value."),(0,n.kt)("p",null,"This approach's advantage is that the idea is relatively simple and implements the STM model. The downside is that the implementation we developed of TL2 is painfully slow, and usually going single thread is faster than using multiple threads.\nWe suspect this poor performance is due to multiple interleaving of threads which force the transactions to be reset multiple times. Further investigation is required to confirm this idea."),(0,n.kt)("h2",{id:"read-log-update-rlu"},"Read-Log-Update (RLU)"),(0,n.kt)("p",null,"RLU is an extension of the more famous ",(0,n.kt)("em",{parentName:"p"},"Read-Copy-Update")," (RCU) that has been widely adopted in the Linux kernel."),(0,n.kt)("p",null,"RLU was first presented in 2015 in the paper ",(0,n.kt)("a",{parentName:"p",href:"http://sigops.org/sosp/sosp15/current/2015-Monterey/printable/077-matveev.pdf"},"Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming"),". "),(0,n.kt)("p",null,"Contrary to ",(0,n.kt)("a",{parentName:"p",href:"#tl2"},"TL2"),", RLU is a blocking algorithm.\nThreads do their computations locally and synchronize with each other using their local clock (when the computations started) and a common global clock.\nA thread logs the new value of any shared memory it has modified."),(0,n.kt)("p",null,"To read shared memory, a thread either does it directly in the memory or fetches it in another thread logs when it has been locked and is being modified.\nWhen a thread wants to commit its computations to the memory, it has to wait for all the other threads that have started with an old memory state to terminate."),(0,n.kt)("p",null,"The upside to this approach is that a thread never needs to redo its computation since it has to wait for the correct timing to commit its work."),(0,n.kt)("p",null,"In return, threads may be idle for some time as they have to wait.\nHowever, the whole RLU algorithm is lock-free. This means that at any moment there is always a thread that advances in its computation, and the whole system cannot be hard-stuck."),(0,n.kt)("h2",{id:"concurrent-programming-with-locks"},"Concurrent Programming with Locks"),(0,n.kt)("p",null,"Using locks is one of the most basic approaches to concurrent programming.\nLocks are used for controlling access to shared memory/variables. Depending on the type of locks used, you can restrict access to a shared memory/variable to either one or a limited number of threads.\nThis prevents data race since the different threads cannot access the shared memory/variables chaotically.\nThe biggest issue is that those locks are generally difficult to use correctly and hard to debug."),(0,n.kt)("p",null,"One of the most problematic situations with locks is a ",(0,n.kt)("strong",{parentName:"p"},"deadlock"),".\nDeadlocks happen when the whole system cannot advance anymore because different threads require some locks to advance their computation, but these locks are kept and blocked by other threads in a similar situation.\nModels like the ",(0,n.kt)("a",{parentName:"p",href:"#the-actor-model"},"actor system")," or the ",(0,n.kt)("a",{parentName:"p",href:"#software-transactional-memory-stm-with-transactional-locking-2-tl2"},"STM")," use locks as little as possible."),(0,n.kt)("p",null,"In our case, Stronghold\u2019s API is relatively straightforward, so we're exploring the idea of using basic locks instead of a resource-heavy concurrent framework."))}d.isMDXComponent=!0}}]);